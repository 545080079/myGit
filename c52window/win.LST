C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE WIN
OBJECT MODULE PLACED IN win.OBJ
COMPILER INVOKED BY: E:\Keil4\C51\BIN\C51.EXE win.c COMPACT BROWSE DEBUG OBJECTEXTEND

line level    source

   1                                                                                                                                                                                                                                                           /***************   writer:shopping.w   ******************/
   2          #include <reg52.h>//库函数
   3          #include <dht11.h> //库函数//如果 实物 打开
   4          #include <adc0832.h> //AD转换库函数
   5          #include <esp8266.h>
   6          
   7          sbit menu=P2^5; //主功能键      
   8          sbit add=P2^4;//加键            
   9          sbit dec=P2^3;// 减键
  10          sbit open=P2^6;// 手动 开
  11          sbit close=P2^7;// 手动 关      
  12          sbit IR=P3^5; //红外感 应
  13          sbit BEEP=P3^1;// 报警
  14          #define MOTORSTEP P1                    //宏定义，定义P1口为步进电机驱动端口     
  15          
  16          uchar  dsflj,kval,lofl,menusw,con,befl,zhenfl,fanfl,brigfl;// 各种变量标记 正返转标记
  17          uint sudu,dwbrigfl,humfl;  //电机速度 //光度下限/湿度标记
  18          uchar count0,second,zhenzhuan,fanzhuan,timeflg,opensw,closesw,keysw;//时钟变量 正反转 变量      
  19          uint adc0,adc1;
  20          uint upbrig,dwbrig,kwbrig,uphum,uptemp,upsmo; // 下限 亮度 上限湿度// 上限温度
  21          uint i;//esp8266
  22          
  23          uint hour,minit,secon,DSdat,VAldat ,time;//时钟变量
  24          
  25          uint ONhour,ONminit,ONsecon; // 开窗时间变量
  26          uint OFhour,OFminit,OFsecon; // 关窗时间变量
  27          uchar   U8T_data_H,U8RH_data_H;
  28          
  29          
  30          #define Imax 14000    //此处为晶振为11.0592时的取值, 
  31          #define Imin 8000    //如用其它频率的晶振时,没
  32          #define Inum1 1450    //要改变相应的取值。
  33          #define Inum2 700 
  34          #define Inum3 3000 
  35          
  36          uchar idata f=0;
  37          uchar idata Im[4]={0x00,0x00,0x00,0x00}; // 遥控码存储空间
  38          uchar idata show[2]={0,0};  // 变量申明
  39          ulong idata m,Tc;         // 变量申明
  40          uchar idata IrOK;               // 变量申明
  41          
  42          
  43          void delay(uint z);// 开窗时间变量
  44          void write_rvalue(); // 显示函数
  45          
  46          void delaymoto()                                        //步进电机每一步间延迟函数
  47          {       
  48   1              uint y=sudu;
  49   1              while(y--);
  50   1      }
  51          
  52          
  53          
  54          uchar code FFW[]={0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09}; //步进电机驱动值数组
  55          
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 2   

  56          uchar code REV[]={0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01}; //步进电机驱动值数组
  57          
  58          xdata num1 [4] =    {0x00,0x00,0x00,0x00,};                             
  59          xdata num2 [4] =    {0x00,0x00,0x00,0x00,};                      
  60          xdata num3 [4] =    {0x00,0x00,0x00,0x00,};                
  61          xdata num4 [4] =    {0x00,0x00,0x00,0x00,};     // AD转换变量组组
  62          xdata num5 [4] =    {0x00,0x00,0x00,0x00,};     // AD转换变量组组
  63          
  64          
  65          
  66          
  67          
  68          
  69          
  70          
  71          
  72            void SETP_MOTOR_FFW()  //反转
  73          {
  74   1                         uint i=0;
  75   1      
  76   1                      for(i=0;i<8;i++) //8步一个循环
  77   1                              {
  78   2                                      MOTORSTEP=FFW[i]; //取值赋给P1驱动口
  79   2                                      delaymoto(); 
  80   2                              }
  81   1      
  82   1       }
  83          
  84          void SETP_MOTOR_REV()  //正转
  85          {
  86   1       
  87   1      
  88   1          uint i=0;
  89   1      
  90   1                      for(i=0;i<8;i++) //8步一个循环
  91   1                              {
  92   2                                      MOTORSTEP=REV[i]; //取值赋给P1驱动口
  93   2                                      delaymoto(); 
  94   2                              }
  95   1      
  96   1      }
  97          
  98          
  99          void write_sfm() // 拆分 个位 十位显示
 100          
 101          {       uchar shi ,ge;
 102   1      
 103   1              shi=DSdat/10;
 104   1              ge=DSdat%10;
 105   1              
 106   1              write_date(0x30+shi);
 107   1              write_date(0x30+ge);    
 108   1      
 109   1      
 110   1      }
 111          
 112          
 113          
 114          
 115          
 116          
 117          
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 3   

 118          void keyscn()//按键扫描函数
 119          {
 120   1        uchar num; //局部变量
 121   1      
 122   1       if(keysw==1)
 123   1       {
 124   2       if(opensw==1)
 125   2      {
 126   3      if(open==0)      // 手动开窗
 127   3              {
 128   4                        write_com(0x80);
 129   4      
 130   4                              for(num=0;num<16;num++)//显示提示语
 131   4                      {
 132   5                              write_date(logo5[num]);
 133   5                              delay(2);
 134   5                      }
 135   4      
 136   4      
 137   4                        write_com(0x80+0x40);
 138   4      
 139   4                              for(num=0;num<16;num++)//显示提示语
 140   4                      {
 141   5                              write_date(logo10[num]);
 142   5                              delay(2);
 143   5                      }
 144   4      
 145   4      
 146   4      
 147   4                       
 148   4                       
 149   4                       closesw=1;     // 已打开标记
 150   4                   delay(10);
 151   4                      if(open==0)
 152   4                      {
 153   5                      while(!open);
 154   5                      zhenzhuan=1;// 正转 开启
 155   5                      fanzhuan=0;      // 返转关闭
 156   5                      second=0;// 秒清零 步进电机 会停
 157   5                      keysw=0;
 158   5                      menusw=0;
 159   5                       }
 160   4               
 161   4                      } 
 162   3               
 163   3       }
 164   2      
 165   2        if(closesw==1)//如果窗户是打开的
 166   2        {
 167   3       if(close==0)//按下手动开
 168   3              {
 169   4      
 170   4                 write_com(0x80);
 171   4      
 172   4                              for(num=0;num<16;num++)//显示提示语
 173   4                      {
 174   5                              write_date(logo6[num]);
 175   5                              delay(2);
 176   5                      }
 177   4      
 178   4                                write_com(0x80+0x40);
 179   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 4   

 180   4                              for(num=0;num<16;num++)
 181   4                      {
 182   5                              write_date(logo10[num]);//显示提示语
 183   5                              delay(2);
 184   5                      }
 185   4      
 186   4      
 187   4                       
 188   4                   delay(10);
 189   4                      if(close==0)
 190   4                      {
 191   5                      while(!close);
 192   5                      zhenzhuan=0;  //正转关
 193   5                      fanzhuan=1;     // 反转 开启
 194   5                      second=0;       // 定时清零
 195   5                      keysw=0; // 标记请零
 196   5                       menusw=0;
 197   5                       }
 198   4               
 199   4                      } 
 200   3      
 201   3       }
 202   2      
 203   2       }
 204   1      
 205   1      
 206   1       if(menusw==1)//如果窗户运行完毕
 207   1      {
 208   2        if(menu==0)// 如果主功能键按下
 209   2              {
 210   3      
 211   3                      lofl=1; //字幕载入
 212   3      
 213   3                      
 214   3      
 215   3                   delay(10); //延时消抖动
 216   3                      if(menu==0)
 217   3                      {
 218   4                      while(!menu);//松手检测
 219   4                       dsflj=0;// 关主页显示
 220   4                       kval++; // 按键变量++
 221   4                       keysw=0;//不允许手动 开窗  和关窗
 222   4                       }
 223   3                       } 
 224   2      
 225   2                       
 226   2      
 227   2      //*************************************************************************8
 228   2      
 229   2        if(kval==1)  // 如果变量==1  进入时间设定
 230   2      
 231   2       {
 232   3        
 233   3        if(lofl==1)
 234   3        {
 235   4       write_com(0x80);
 236   4      
 237   4                              for(num=0;num<16;num++)
 238   4                      {
 239   5                              write_date(logo12[num]);//显示提示语
 240   5                              delay(2);
 241   5      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 5   

 242   5                      
 243   5                      }
 244   4      
 245   4      
 246   4      
 247   4                 write_com(0x80+0x40);
 248   4      
 249   4                              for(num=0;num<16;num++) //显示提示语
 250   4                      {
 251   5                              write_date(logo9[num]);
 252   5                              delay(2);
 253   5      
 254   5                              lofl=0;
 255   5                      }
 256   4      
 257   4      
 258   4      
 259   4      
 260   4                      DSdat=hour;
 261   4              write_com(0x80+8);      // 刷新 设定时间
 262   4                      write_sfm();
 263   4      
 264   4      
 265   4             
 266   4                      DSdat=minit;
 267   4                  write_com(0x80+11);// 刷新 设定时间
 268   4                  write_sfm();
 269   4      
 270   4                       DSdat=secon;
 271   4                      write_com(0x80+14);     // 刷新 设定时间
 272   4                      write_sfm();
 273   4      
 274   4      
 275   4      
 276   4      }
 277   3      
 278   3      
 279   3       }
 280   2      
 281   2      
 282   2      
 283   2      //uint hour,minit,secon;
 284   2      
 285   2         if(kval==2)//如果变量=2 进入小时设定
 286   2      
 287   2       {DSdat=hour;     // 刷新显示小时
 288   3        
 289   3        
 290   3        write_com(0x40+0x40+8);// 显示坐标
 291   3        write_com(0x0e);
 292   3                                                 // 开关标
 293   3      
 294   3        
 295   3      if(add==0)// 如果加键按下
 296   3      
 297   3      {
 298   4      
 299   4      while(!add); // 松手检测
 300   4       
 301   4      
 302   4      hour++; //小时++
 303   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 6   

 304   4      DSdat=hour; //送显示
 305   4      write_sfm(); // 拆分
 306   4      if(hour==24)  //
 307   4      {hour=0;}
 308   4      
 309   4      
 310   4      
 311   4      }
 312   3      
 313   3      
 314   3      
 315   3      
 316   3      
 317   3       if( dec==0) // 如果减键按下
 318   3      
 319   3      {
 320   4      
 321   4      while(! dec);// 松手检测
 322   4       
 323   4      
 324   4      hour--;  //小时--
 325   4      DSdat=hour;
 326   4      write_sfm(); //拆分限位
 327   4      if(hour==0)//限位
 328   4      {hour=23;}
 329   4      
 330   4      
 331   4      
 332   4      
 333   4      }
 334   3      
 335   3       }
 336   2      
 337   2      
 338   2      
 339   2      
 340   2      
 341   2      
 342   2      
 343   2       //**************************以下时 分钟设 定 秒钟设定 和上面小时一样
 344   2       //只是就量不一样 不作注释*******************************************
 345   2       //********************************************************************
 346   2       
 347   2         if(kval==3)
 348   2      
 349   2       {
 350   3      
 351   3      
 352   3      DSdat=minit;
 353   3      
 354   3        write_com(0x40+0x40+11);
 355   3        write_com(0x0e);
 356   3      
 357   3      
 358   3        
 359   3      if(add==0)
 360   3      
 361   3      {
 362   4      
 363   4      while(!add);
 364   4       
 365   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 7   

 366   4      minit++;
 367   4      
 368   4      DSdat=minit;
 369   4      write_sfm();
 370   4      if(minit==60)
 371   4      {minit=0;}
 372   4      
 373   4      
 374   4      
 375   4      }
 376   3      
 377   3      
 378   3      
 379   3      
 380   3      
 381   3       if( dec==0)
 382   3      
 383   3      {
 384   4      
 385   4      while(! dec);
 386   4       
 387   4      
 388   4      minit--;
 389   4      
 390   4      DSdat=minit;
 391   4      write_sfm();
 392   4      if(minit==0)
 393   4      {minit=59;}
 394   4      
 395   4      
 396   4      
 397   4      }
 398   3      
 399   3       }
 400   2      
 401   2      
 402   2      
 403   2      
 404   2      
 405   2      
 406   2      
 407   2      
 408   2      
 409   2      
 410   2      
 411   2      
 412   2      
 413   2       
 414   2         if(kval==4)
 415   2      
 416   2       { 
 417   3       
 418   3       
 419   3       DSdat=secon;
 420   3        
 421   3        write_com(0x40+0x40+14);
 422   3        write_com(0x0e);
 423   3      
 424   3      
 425   3        
 426   3      if(add==0)
 427   3      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 8   

 428   3      {
 429   4      
 430   4      while(!add);
 431   4       
 432   4      
 433   4      secon++;
 434   4      
 435   4      DSdat=secon;
 436   4      write_sfm();
 437   4      if(secon==60)
 438   4      {secon=0;}
 439   4      
 440   4      
 441   4      
 442   4      }
 443   3      
 444   3      
 445   3      
 446   3      
 447   3      
 448   3       if( dec==0)
 449   3      
 450   3      {
 451   4      
 452   4      while(! dec);
 453   4       
 454   4      
 455   4      secon--;
 456   4      
 457   4      DSdat=secon;
 458   4      write_sfm();
 459   4      if(secon==0)
 460   4      {secon=59;}
 461   4      
 462   4      
 463   4      
 464   4      }
 465   3      
 466   3       }
 467   2      
 468   2      
 469   2      //uint ONhour,ONminit,ONsecon;
 470   2      //uint OFhour,OFminit,OFsecon;
 471   2      
 472   2       
 473   2      
 474   2       //**************************以下 开窗时  小时 分钟设 定 秒钟设定 和上面小时一样
 475   2       //只是就量不一样 不作注释*******************************************
 476   2       //**************
 477   2      
 478   2      //*************************************设定开时****************************************
 479   2       
 480   2         if(kval==5)
 481   2      
 482   2       {
 483   3        
 484   3         if(lofl==1)
 485   3        {
 486   4       write_com(0x80);
 487   4      
 488   4                              for(num=0;num<16;num++)
 489   4                      {
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 9   

 490   5                              write_date(logo13[num]);
 491   5                              delay(2);
 492   5      
 493   5                      
 494   5                      }
 495   4      
 496   4      
 497   4      
 498   4                 write_com(0x80+0x40);
 499   4      
 500   4                              for(num=0;num<16;num++)
 501   4                      {
 502   5                              write_date(logo9[num]);
 503   5                              delay(2);
 504   5      
 505   5                      
 506   5                      }
 507   4      
 508   4      
 509   4      
 510   4                      DSdat=ONhour;
 511   4              write_com(0x80+8);
 512   4                      write_sfm();
 513   4      
 514   4      
 515   4                      DSdat=ONminit;
 516   4                  write_com(0x80+11);
 517   4                  write_sfm();
 518   4      
 519   4      
 520   4             DSdat=ONsecon;
 521   4                      write_com(0x80+14);
 522   4                      write_sfm();
 523   4      
 524   4              
 525   4                      
 526   4      
 527   4      
 528   4                      lofl=0;
 529   4      
 530   4      
 531   4      
 532   4      
 533   4      
 534   4      }
 535   3      
 536   3      
 537   3      
 538   3      
 539   3      
 540   3      }
 541   2      
 542   2       
 543   2      
 544   2      
 545   2        if(kval==6)
 546   2      
 547   2       {
 548   3        
 549   3        write_com(0x80+0x08);
 550   3        write_com(0x0e);
 551   3      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 10  

 552   3      
 553   3        
 554   3      if(add==0)
 555   3      
 556   3      {
 557   4      
 558   4      while(!add);
 559   4       
 560   4      
 561   4      ONhour++;
 562   4      
 563   4      DSdat=ONhour;
 564   4      write_sfm();
 565   4      if(ONhour==24)
 566   4      {ONhour=0;}
 567   4      
 568   4      
 569   4      
 570   4      }
 571   3      
 572   3      
 573   3      
 574   3      
 575   3      
 576   3       if( dec==0)
 577   3      
 578   3      {
 579   4      
 580   4      while(! dec);
 581   4       
 582   4      
 583   4      ONhour--;
 584   4      
 585   4      DSdat=ONhour;
 586   4      write_sfm();
 587   4      if(ONhour==0)
 588   4      {ONhour=23;}
 589   4      
 590   4      
 591   4      
 592   4      }
 593   3      
 594   3       }
 595   2      
 596   2      
 597   2      
 598   2      
 599   2      
 600   2      
 601   2         if(kval==7)
 602   2      
 603   2       {
 604   3        
 605   3        write_com(0x40+0x40+11);
 606   3        write_com(0x0e);
 607   3      
 608   3      
 609   3        
 610   3      if(add==0)
 611   3      
 612   3      {
 613   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 11  

 614   4      while(!add);
 615   4       
 616   4      
 617   4      ONminit++;
 618   4      
 619   4      DSdat=ONminit;
 620   4      write_sfm();
 621   4      if(ONminit==60)
 622   4      {ONminit=0;}
 623   4      
 624   4      
 625   4      
 626   4      }
 627   3      
 628   3      
 629   3      
 630   3      
 631   3      
 632   3       if( dec==0)
 633   3      
 634   3      {
 635   4      
 636   4      while(! dec);
 637   4       
 638   4      
 639   4      ONminit--;
 640   4      
 641   4      DSdat=ONminit;
 642   4      write_sfm();
 643   4      if(ONminit==0)
 644   4      {ONminit=59;}
 645   4      
 646   4      
 647   4      
 648   4      }
 649   3      
 650   3       }
 651   2      
 652   2      
 653   2      
 654   2      
 655   2      
 656   2      
 657   2        if(kval==8)
 658   2      
 659   2       {
 660   3        
 661   3        write_com(0x40+0x40+14);
 662   3        write_com(0x0e);
 663   3      
 664   3      
 665   3        
 666   3      if(add==0)
 667   3      
 668   3      {
 669   4      
 670   4      while(!add);
 671   4       
 672   4      
 673   4      ONsecon++;
 674   4      
 675   4      DSdat=ONsecon;
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 12  

 676   4      write_sfm();
 677   4      if(ONsecon==60)
 678   4      {ONsecon=0;}
 679   4      
 680   4      
 681   4      
 682   4      }
 683   3      
 684   3      
 685   3      
 686   3      
 687   3      
 688   3       if( dec==0)
 689   3      
 690   3      {
 691   4      
 692   4      while(! dec);
 693   4       
 694   4      
 695   4      ONsecon--;
 696   4      
 697   4      DSdat=ONsecon;
 698   4      write_sfm();
 699   4      if(ONsecon==0)
 700   4      {ONsecon=59;}
 701   4      
 702   4      
 703   4      
 704   4      }
 705   3      
 706   3       }
 707   2       
 708   2      
 709   2       //**************************以下 关窗时  小时 分钟设 定 秒钟设定 和上面小时一样
 710   2       //只是就量不一样 不作注释*******************************************
 711   2       //**************
 712   2      
 713   2      
 714   2      //**************************************设定关时间**************************************
 715   2              
 716   2              
 717   2       
 718   2         if(kval==9)
 719   2      
 720   2       {
 721   3        
 722   3         if(lofl==1)
 723   3        {
 724   4       write_com(0x80);
 725   4      
 726   4                              for(num=0;num<16;num++)
 727   4                      {
 728   5                              write_date(logo14[num]);
 729   5                              delay(2);
 730   5      
 731   5                      
 732   5                      }
 733   4      
 734   4      
 735   4      
 736   4                 write_com(0x80+0x40);
 737   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 13  

 738   4                              for(num=0;num<16;num++)
 739   4                      {
 740   5                              write_date(logo9[num]);
 741   5                              delay(2);
 742   5      
 743   5                              lofl=0;
 744   5                      }
 745   4      
 746   4      
 747   4                      DSdat=OFhour;
 748   4              write_com(0x80+8);
 749   4                      write_sfm();
 750   4      
 751   4      
 752   4                      DSdat=OFminit;
 753   4                  write_com(0x80+11);
 754   4                  write_sfm();
 755   4      
 756   4                      
 757   4      
 758   4              DSdat=OFsecon;
 759   4                      write_com(0x80+14);
 760   4                      write_sfm();
 761   4      
 762   4                      
 763   4      
 764   4      }
 765   3      
 766   3      
 767   3      
 768   3      
 769   3      
 770   3      }       
 771   2              
 772   2              
 773   2              
 774   2              
 775   2              
 776   2              
 777   2              
 778   2              
 779   2                      
 780   2       if(kval==10)
 781   2      
 782   2       {
 783   3        
 784   3        write_com(0x80+0x08);
 785   3        write_com(0x0e);
 786   3      
 787   3      
 788   3        
 789   3      if(add==0)
 790   3      
 791   3      {
 792   4      
 793   4      while(!add);
 794   4       
 795   4      
 796   4      OFhour++;
 797   4      
 798   4      DSdat=OFhour;
 799   4      write_sfm();
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 14  

 800   4      if(OFhour==24)
 801   4      {OFhour=0;}
 802   4      
 803   4      
 804   4      
 805   4      }
 806   3      
 807   3      
 808   3      
 809   3      
 810   3      
 811   3       if( dec==0)
 812   3      
 813   3      {
 814   4      
 815   4      while(! dec);
 816   4       
 817   4      
 818   4      OFhour--;
 819   4      
 820   4      DSdat=OFhour;
 821   4      write_sfm();
 822   4      if(OFhour==0)
 823   4      {OFhour=23;}
 824   4      
 825   4      
 826   4      
 827   4      }
 828   3      
 829   3       }
 830   2      
 831   2      
 832   2      
 833   2      
 834   2      
 835   2      
 836   2         if(kval==11)
 837   2      
 838   2       {
 839   3        
 840   3        write_com(0x40+0x40+11);
 841   3        write_com(0x0e);
 842   3      
 843   3      
 844   3        
 845   3      if(add==0)
 846   3      
 847   3      {
 848   4      
 849   4      while(!add);
 850   4       
 851   4      
 852   4      OFminit++;
 853   4      
 854   4      DSdat=OFminit;
 855   4      write_sfm();
 856   4      if(OFminit==60)
 857   4      {OFminit=0;}
 858   4      
 859   4      
 860   4      
 861   4      }
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 15  

 862   3      
 863   3      
 864   3      
 865   3      
 866   3      
 867   3       if( dec==0)
 868   3      
 869   3      {
 870   4      
 871   4      while(! dec);
 872   4       
 873   4      
 874   4      OFminit--;
 875   4      
 876   4      DSdat=OFminit;
 877   4      write_sfm();
 878   4      if(OFminit==0)
 879   4      {OFminit=59;}
 880   4      
 881   4      
 882   4      
 883   4      }
 884   3      
 885   3       }
 886   2      
 887   2      
 888   2      
 889   2      
 890   2      
 891   2      
 892   2      
 893   2      
 894   2      
 895   2      
 896   2      
 897   2      
 898   2        if(kval==12)
 899   2      
 900   2       {
 901   3        
 902   3        write_com(0x40+0x40+14);
 903   3        write_com(0x0e);
 904   3      
 905   3      
 906   3        
 907   3      if(add==0)
 908   3      
 909   3      {
 910   4      
 911   4      while(!add);
 912   4       
 913   4      
 914   4      OFsecon++;
 915   4      
 916   4      DSdat=OFsecon;
 917   4      write_sfm();
 918   4      if(OFsecon==60)
 919   4      {OFsecon=0;}
 920   4      
 921   4      
 922   4      
 923   4      }
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 16  

 924   3      
 925   3      
 926   3      
 927   3      
 928   3      
 929   3       if( dec==0)
 930   3      
 931   3      {
 932   4      
 933   4      while(! dec);
 934   4       
 935   4      
 936   4      OFsecon--;
 937   4      
 938   4      DSdat=OFsecon;
 939   4      write_sfm();
 940   4      if(OFsecon==0)
 941   4      {OFsecon=59;}
 942   4      
 943   4      
 944   4      
 945   4      }
 946   3      
 947   3       }
 948   2      
 949   2      
 950   2      
 951   2      
 952   2      
 953   2      
 954   2      
 955   2      
 956   2      
 957   2      
 958   2       
 959   2      
 960   2       //**************************以下 亮度会上设定  和上面小时一样
 961   2       //只是就量不一样 不作注释*******************************************
 962   2       //**************
 963   2      
 964   2      
 965   2        //********************************设定环境参数************************************
 966   2       
 967   2        if(kval==13)
 968   2      
 969   2       {
 970   3      
 971   3         write_com(0x0c);
 972   3      
 973   3         num4[4]=dwbrig;
 974   3         write_rvalue();
 975   3        if(lofl==1)
 976   3        {
 977   4       write_com(0x80);
 978   4      
 979   4                              for(num=0;num<16;num++)
 980   4                      {
 981   5                              write_date(logo7[num]);
 982   5                              delay(2);
 983   5      
 984   5                      
 985   5                      }
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 17  

 986   4      
 987   4      
 988   4      
 989   4                 write_com(0x80+0x40);
 990   4      
 991   4                              for(num=0;num<16;num++)
 992   4                      {
 993   5                              write_date(logo9[num]);
 994   5                              delay(2);
 995   5      
 996   5                              lofl=0;
 997   5                      }
 998   4      
 999   4      
1000   4      }
1001   3      
1002   3      
1003   3          if(add==0)  
1004   3              {
1005   4                 delay(10);
1006   4      
1007   4                  
1008   4                      if(add==0)
1009   4                      {
1010   5                      while(!add);                                                            
1011   5                       dwbrig++;
1012   5                       num4[4]=dwbrig;
1013   5                       write_rvalue();
1014   5      
1015   5      
1016   5               if(dwbrig==250)
1017   5                {dwbrig=0;}
1018   5      
1019   5      
1020   5                       }
1021   4                       } 
1022   3      
1023   3      
1024   3      
1025   3                      if(dec==0)      
1026   3              {
1027   4                 delay(10);
1028   4      
1029   4                  
1030   4                      if(dec==0)
1031   4                      {
1032   5                      while(!dec);                                                            
1033   5                       dwbrig--;
1034   5                       num4[4]=dwbrig;
1035   5                       write_rvalue();
1036   5      
1037   5      
1038   5               if(dwbrig==0)
1039   5                {dwbrig=250;}
1040   5      
1041   5      
1042   5                       }
1043   4                       } 
1044   3      
1045   3      
1046   3       }
1047   2      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 18  

1048   2      
1049   2      
1050   2      
1051   2      
1052   2      
1053   2      
1054   2      
1055   2      
1056   2      
1057   2      
1058   2      //*********************************************************************
1059   2      
1060   2      
1061   2         //********************************设定环境参数************************************
1062   2       
1063   2        if(kval==14)
1064   2      
1065   2       {
1066   3      
1067   3         write_com(0x0c);
1068   3      
1069   3         num4[4]=kwbrig;
1070   3         write_rvalue();
1071   3        if(lofl==1)
1072   3        {
1073   4       write_com(0x80);
1074   4      
1075   4                              for(num=0;num<16;num++)
1076   4                      {
1077   5                              write_date(logo16[num]);
1078   5                              delay(2);
1079   5      
1080   5                      
1081   5                      }
1082   4      
1083   4      
1084   4      
1085   4                 write_com(0x80+0x40);
1086   4      
1087   4                              for(num=0;num<16;num++)
1088   4                      {
1089   5                              write_date(logo9[num]);
1090   5                              delay(2);
1091   5      
1092   5                              lofl=0;
1093   5                      }
1094   4      
1095   4      
1096   4      }
1097   3      
1098   3      
1099   3          if(add==0)  
1100   3              {
1101   4                 delay(10);
1102   4      
1103   4                  
1104   4                      if(add==0)
1105   4                      {
1106   5                      while(!add);                                                            
1107   5                       kwbrig++;
1108   5                       num4[4]=kwbrig;
1109   5                       write_rvalue();
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 19  

1110   5      
1111   5      
1112   5               if(kwbrig==250)
1113   5                {kwbrig=0;}
1114   5      
1115   5      
1116   5                       }
1117   4                       } 
1118   3      
1119   3      
1120   3      
1121   3                      if(dec==0)      
1122   3              {
1123   4                 delay(10);
1124   4      
1125   4                  
1126   4                      if(dec==0)
1127   4                      {
1128   5                      while(!dec);                                                            
1129   5                       kwbrig--;
1130   5                       num4[4]=kwbrig;
1131   5                       write_rvalue();
1132   5      
1133   5      
1134   5               if(kwbrig==0)
1135   5                {kwbrig=250;}
1136   5      
1137   5      
1138   5                       }
1139   4                       } 
1140   3      
1141   3      
1142   3       }
1143   2      
1144   2      
1145   2      
1146   2      
1147   2      
1148   2      
1149   2      
1150   2      
1151   2      
1152   2      
1153   2      
1154   2      
1155   2      
1156   2       
1157   2       //**************************以下 湿度会上设定  和上面小时一样
1158   2       //只是就量不一样 不作注释*******************************************
1159   2       //**************               
1160   2       if(kval==15)
1161   2      
1162   2       {
1163   3         num4[4]=uphum;
1164   3         write_rvalue();
1165   3        if(lofl==1)
1166   3        {
1167   4       write_com(0x80);
1168   4      
1169   4                              for(num=0;num<16;num++)
1170   4                      {
1171   5                              write_date(logo8[num]);
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 20  

1172   5                              delay(2);
1173   5      
1174   5                      
1175   5                      }
1176   4      
1177   4      
1178   4      
1179   4                 write_com(0x80+0x40);
1180   4      
1181   4                              for(num=0;num<16;num++)
1182   4                      {
1183   5                              write_date(logo9[num]);
1184   5                              delay(2);
1185   5      
1186   5                              lofl=0;
1187   5                      }
1188   4      
1189   4      
1190   4      }
1191   3      
1192   3      
1193   3                 
1194   3      
1195   3                
1196   3      
1197   3      
1198   3      
1199   3      
1200   3          if(add==0)  
1201   3              {
1202   4                 delay(10);
1203   4      
1204   4                  
1205   4                      if(add==0)
1206   4                      {
1207   5                      while(!add);                                                            
1208   5                       uphum++;
1209   5                       num4[4]=uphum;
1210   5                       write_rvalue();
1211   5      
1212   5      
1213   5               if(uphum==100)
1214   5                {uphum=0;}
1215   5      
1216   5      
1217   5                       }
1218   4                       } 
1219   3      
1220   3      
1221   3      
1222   3                      if(dec==0)      
1223   3              {
1224   4                 delay(10);
1225   4      
1226   4                  
1227   4                      if(dec==0)
1228   4                      {
1229   5                      while(!dec);                                                            
1230   5                       uphum--;
1231   5                       num4[4]=uphum;
1232   5                       write_rvalue();
1233   5      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 21  

1234   5      
1235   5               if(uphum==0)
1236   5                {uphum=100;}
1237   5      
1238   5      
1239   5                       }
1240   4                       } 
1241   3      
1242   3      
1243   3       }
1244   2      
1245   2      
1246   2      
1247   2      
1248   2      
1249   2       
1250   2       //**************************以下 温度度会上设定  和上面小时一样
1251   2       //只是就量不一样 不作注释*******************************************
1252   2       //**************                               
1253   2       if(kval==16)
1254   2      
1255   2       {
1256   3         num4[4]=uptemp;
1257   3         write_rvalue();
1258   3        if(lofl==1)
1259   3        {
1260   4       write_com(0x80);
1261   4      
1262   4                              for(num=0;num<16;num++)
1263   4                      {
1264   5                              write_date(logo11[num]);
1265   5                              delay(2);
1266   5      
1267   5                      
1268   5                      }
1269   4      
1270   4      
1271   4      
1272   4                 write_com(0x80+0x40);
1273   4      
1274   4                              for(num=0;num<16;num++)
1275   4                      {
1276   5                              write_date(logo9[num]);
1277   5                              delay(2);
1278   5      
1279   5                              lofl=0;
1280   5                      }
1281   4      
1282   4      
1283   4      }
1284   3      
1285   3      
1286   3                 
1287   3      
1288   3                
1289   3      
1290   3      
1291   3      
1292   3      
1293   3          if(add==0)  
1294   3              {
1295   4                 delay(10);
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 22  

1296   4      
1297   4                  
1298   4                      if(add==0)
1299   4                      {
1300   5                      while(!add);                                                            
1301   5                       uptemp++;
1302   5                       num4[4]=uptemp;
1303   5                       write_rvalue();
1304   5      
1305   5      
1306   5               if(uptemp==100)
1307   5                {uptemp=0;}
1308   5      
1309   5      
1310   5                       }
1311   4                       } 
1312   3      
1313   3      
1314   3      
1315   3                      if(dec==0)      
1316   3              {
1317   4                 delay(10);
1318   4      
1319   4                  
1320   4                      if(dec==0)
1321   4                      {
1322   5                      while(!dec);                                                            
1323   5                       uptemp--;
1324   5                       num4[4]=uptemp;
1325   5                       write_rvalue();
1326   5      
1327   5      
1328   5               if(uptemp==0)
1329   5                {uptemp=100;}
1330   5      
1331   5      
1332   5                       }
1333   4                       } 
1334   3      
1335   3      
1336   3       }
1337   2      
1338   2      
1339   2      
1340   2      
1341   2      
1342   2       
1343   2      
1344   2       //**************************以下烟雾度会上设定  和上面小时一样
1345   2       //只是就量不一样 不作注释*******************************************
1346   2       //**************                               
1347   2       if(kval==17)
1348   2      
1349   2       {
1350   3         num4[4]=upsmo;
1351   3         write_rvalue();
1352   3        if(lofl==1)
1353   3        {
1354   4       write_com(0x80);
1355   4      
1356   4                              for(num=0;num<16;num++)
1357   4                      {
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 23  

1358   5                              write_date(logo15[num]);
1359   5                              delay(2);
1360   5      
1361   5                      
1362   5                      }
1363   4      
1364   4      
1365   4      
1366   4                 write_com(0x80+0x40);
1367   4      
1368   4                              for(num=0;num<16;num++)
1369   4                      {
1370   5                              write_date(logo9[num]);
1371   5                              delay(2);
1372   5      
1373   5                              lofl=0;
1374   5                      }
1375   4      
1376   4      
1377   4      }
1378   3      
1379   3      
1380   3                 
1381   3      
1382   3                
1383   3      
1384   3      
1385   3      
1386   3      
1387   3          if(add==0)  
1388   3              {
1389   4                 delay(10);
1390   4      
1391   4                  
1392   4                      if(add==0)
1393   4                      {
1394   5                      while(!add);                                                            
1395   5                       upsmo++;
1396   5                       num4[4]=upsmo;
1397   5                       write_rvalue();
1398   5      
1399   5      
1400   5               if(upsmo==100)
1401   5                {upsmo=0;}
1402   5      
1403   5      
1404   5                       }
1405   4                       } 
1406   3      
1407   3      
1408   3      
1409   3                      if(dec==0)      
1410   3              {
1411   4                 delay(10);
1412   4      
1413   4                  
1414   4                      if(dec==0)
1415   4                      {
1416   5                      while(!dec);                                                            
1417   5                       upsmo--;
1418   5                       num4[4]=upsmo;
1419   5                       write_rvalue();
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 24  

1420   5      
1421   5      
1422   5               if(uptemp==0)
1423   5                {upsmo=100;}
1424   5      
1425   5      
1426   5                       }
1427   4                       } 
1428   3      
1429   3      
1430   3       }
1431   2      
1432   2      
1433   2      
1434   2      
1435   2      
1436   2      
1437   2      
1438   2      
1439   2      
1440   2      
1441   2      
1442   2      
1443   2       
1444   2      
1445   2      
1446   2         
1447   2       
1448   2       //*****退出设定*********               
1449   2      
1450   2      
1451   2        if(kval==18)
1452   2      
1453   2       {
1454   3      
1455   3      
1456   3      
1457   3        
1458   3         write_com(0x0c);
1459   3       
1460   3      
1461   3      kval=0;
1462   3        
1463   3      dsflj=1;
1464   3      lofl=1;
1465   3      keysw=1;
1466   3        if(lofl==1)
1467   3        {
1468   4       write_com(0x80);
1469   4      
1470   4                              for(num=0;num<16;num++)
1471   4                      {
1472   5                              write_date(logo4[num]);//字幕显示
1473   5                              delay(2);
1474   5                      }
1475   4      
1476   4      
1477   4                 write_com(0x80+0x40);
1478   4      
1479   4                              for(num=0;num<16;num++)//字幕显示
1480   4                      {
1481   5                              write_date(logo3[num]);
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 25  

1482   5                              delay(2);
1483   5                      }
1484   4      
1485   4      
1486   4      
1487   4      
1488   4                 lofl=0;
1489   4      
1490   4                }
1491   3      
1492   3      
1493   3      
1494   3      
1495   3      
1496   3      
1497   3        }
1498   2      
1499   2      
1500   2      
1501   2      
1502   2      
1503   2       }
1504   1      
1505   1      
1506   1      
1507   1      
1508   1      
1509   1      
1510   1      
1511   1      
1512   1      
1513   1      
1514   1       }
1515          
1516          
1517                  
1518          //步进电机函数
1519           void setmoto()
1520           {
1521   1        char num;
1522   1       //zhenfl fanfl
1523   1      
1524   1         if(zhenzhuan==1)      //正转
1525   1                 {
1526   2                       dsflj=0;
1527   2                        SETP_MOTOR_REV();
1528   2                       
1529   2                      if(second==10)
1530   2                      {
1531   3                      zhenzhuan=0;
1532   3                      P1=0X00;
1533   3                      dsflj=1;
1534   3                      opensw=0;
1535   3                      closesw=1;
1536   3                      keysw=1;
1537   3                 menusw=1;
1538   3      
1539   3      
1540   3                      zhenfl=1;
1541   3                      fanfl=0;
1542   3                      brigfl=0;
1543   3                       humfl=0;
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 26  

1544   3      
1545   3      
1546   3                      write_com(0x80);
1547   3                              for(num=0;num<16;num++)
1548   3                      {                                                  //字幕显示
1549   4                              write_date(logo4[num]);
1550   4                              delay(2);
1551   4                      }
1552   3      
1553   3      
1554   3                              write_com(0x80+0x40);   //字幕显示
1555   3                              for(num=0;num<16;num++)
1556   3                      {
1557   4                              write_date(logo3[num]);
1558   4                              delay(2);
1559   4                      }
1560   3      
1561   3      
1562   3      
1563   3                      }
1564   2      
1565   2      
1566   2              
1567   2      
1568   2                 }
1569   1              
1570   1                      
1571   1      
1572   1                      
1573   1           if(fanzhuan==1)  //反转
1574   1                 { dsflj=0;
1575   2                      
1576   2                        SETP_MOTOR_FFW();
1577   2                       
1578   2                      if(second==10)
1579   2                      { second=0;
1580   3                              P1=0X00;
1581   3      
1582   3                      zhenfl=0;
1583   3                      fanfl=1;        
1584   3         
1585   3                       fanzhuan=0;
1586   3                       dsflj=1;
1587   3                       
1588   3                       dwbrigfl=0;
1589   3                       brigfl=0;
1590   3      
1591   3      
1592   3                      opensw=1;
1593   3                      closesw=0;
1594   3                      keysw=1;
1595   3                      menusw=1;
1596   3                  humfl=1;
1597   3                
1598   3                          
1599   3      
1600   3                      write_com(0x80);
1601   3      
1602   3                              for(num=0;num<16;num++)  //字幕显示
1603   3                      {
1604   4                              write_date(logo4[num]);
1605   4                              delay(2);
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 27  

1606   4                      }
1607   3      
1608   3                                      write_com(0x80+0x40);
1609   3                              for(num=0;num<16;num++)
1610   3                      {                                                         //字幕显示
1611   4                              write_date(logo3[num]);
1612   4                              delay(2);
1613   4                      }
1614   3      
1615   3      
1616   3                       
1617   3                      }
1618   2      
1619   2      
1620   2      
1621   2                      
1622   2      
1623   2      
1624   2      
1625   2                 }
1626   1                      
1627   1       
1628   1       }
1629           
1630          void TEMPHRDSPLAY()                 //显示空气温湿度函数   写入1602
1631          {  
1632   1          num1[4]=U8T_data_H;         //温度高8位，即是整数部分  
1633   1          num1[1]=num1[4]/10; //整数十位
1634   1          num1[0]=num1[4]%10; //整数个位
1635   1              
1636   1          write_com(0x80+0x40+7);                              //显示温度
1637   1              write_date(0x30+num1[1]);
1638   1              write_date(0x30+num1[0]);
1639   1      
1640   1      
1641   1      
1642   1      
1643   1      
1644   1              num2[4]=U8RH_data_H;    //湿度高8位，即是整数部分  
1645   1          num2[3]=num2[4]/10; //整数十位
1646   1          num2[2]=num2[4]%10; //整数个位
1647   1      
1648   1          write_com(0x80+0x40+13);                     //显示湿度
1649   1              write_date(0x30+num2[3]);
1650   1              write_date(0x30+num2[2]);
1651   1      
1652   1      }       
1653          
1654          
1655            
1656           
1657          
1658          
1659           
1660          void SMOGDSPLAY()                   //显示空气温湿度函数   写入1602
1661          {  
1662   1          num3[4]=adc0;               //温度高8位，即是整数部分 
1663   1               
1664   1      
1665   1          
1666   1               
1667   1          num3[0]=num3[4]%10;         //显示ge位  
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 28  

1668   1              num3[1]=num3[4]%100/10;   //显示shi位
1669   1              num3[2]=num3[4]%1000/100;//显示百位
1670   1              
1671   1          write_com(0x80+0X40+2);                              
1672   1              write_date(0x30+num3[2]);
1673   1              write_date(0x30+num3[1]);
1674   1              write_date(0x30+num3[0]);
1675   1      
1676   1       }
1677          
1678            
1679          
1680          
1681          
1682          
1683          
1684          
1685          
1686          
1687          void BRDSPLAY() 
1688          {  
1689   1          
1690   1               
1691   1              num5[4]=adc1;           //温度高8位，即是整数部分 
1692   1          
1693   1               
1694   1          num5[0]=num5[4]%10;         //显示ge位  
1695   1              num5[1]=num5[4]%100/10;   //显示shi位
1696   1              num5[2]=num5[4]%1000/100;//显示百位
1697   1      
1698   1          write_com(0x80+3);                  
1699   1              write_date(0x30+num5[2]);
1700   1              write_date(0x30+num5[1]);
1701   1              write_date(0x30+num5[0]);
1702   1      
1703   1        }
1704          
1705            
1706          
1707          void write_rvalue()
1708          
1709          {    
1710   1      
1711   1          
1712   1               
1713   1          num4[0]=num4[4]%10;         //显示ge位  
1714   1              num4[1]=num4[4]%100/10;   //显示shi位
1715   1              num4[2]=num4[4]%1000/100;//显示百位
1716   1      
1717   1      
1718   1      
1719   1          write_com(0x80+7);                           //显示温度
1720   1              write_date(0x30+num4[2]);
1721   1              write_date(0x30+num4[1]);
1722   1              write_date(0x30+num4[0]);
1723   1       }
1724          
1725          
1726          
1727          
1728          
1729          
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 29  

1730          
1731          void init()
1732          {
1733   1      
1734   1              TMOD=0X11;                                      //定时器设置
1735   1              TH0=0X3C;                                       //定时器0置初值 0.05S
1736   1              TL0=0XBA;
1737   1              EA=1;                                           //开总中断
1738   1              ET0=1;                                          //定时器0中断开启
1739   1              TR0=1;                                          //启动定时0
1740   1      
1741   1      
1742   1      
1743   1      
1744   1              TL1=0X3C;               //定时初值
1745   1              TH1=0XBA;               //定时初值
1746   1                               //总中断打开
1747   1              TR1=1;           //启动定时器
1748   1              ET1=1;           //软件没用到
1749   1              
1750   1      
1751   1      
1752   1              RCAP2H =(0xFFFF-50000)/256;                //赋T2的预置值0x1000，溢出30次就是1秒钟
1753   1          RCAP2L =(0xFFFF-50000)%256;   
1754   1          TR2=1;                       //启动定时器
1755   1          ET2=1;   
1756   1      
1757   1      
1758   1          IT1=1;
1759   1              TH0=0;  //定时器0初值
1760   1              TL0=0;  //定时器0初值
1761   1          TR0=1;      //定时器0启动      
1762   1              EX1=1;  //外部中断 软件没用到
1763   1      
1764   1      
1765   1              
1766   1      }
1767            
1768          
1769          void open8266() //esp8266.h封装 一次命令
1770          {
1771   1              while(1)
1772   1              {
1773   2                      ManyConnect_AP(); 
1774   2      
1775   2      
1776   2                                                      write_com(0x80);
1777   2                                                      for(num=0;num<16;num++)
1778   2                                                      {
1779   3                                                              write_date(waitMess[num]);//显示提示
1780   3                                                              delay(2);
1781   3                                                      }
1782   2                                                      delays();
1783   2                                                      delays500ms();
1784   2                                                                              
1785   2      
1786   2                      while(1)
1787   2                      {        
1788   3                              delays();
1789   3      
1790   3                              BEEP=0;//关蜂鸣器       
1791   3                                                
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 30  

1792   3                       //由于消息的开头是+IP 故做此判断+IPD11,330
1793   3                              if((Usart_Receive[0]=='+')&&(Usart_Receive[1]=='I')&&(Usart_Receive[2]=='P'))
1794   3                              {                  
1795   4      
1796   4                                      if((Usart_Receive[3]=='D')&&(Usart_Receive[6]==','))
1797   4                                      {
1798   5                                              if(Usart_Receive[7]=='1' || Usart_Receive[7]=='1'-'0') //if 1bits data
1799   5                                              {
1800   6                                                      delays500ms(); 
1801   6      
1802   6                                                      write_com(0x80);
1803   6                                                      for(num=0;num<16;num++)
1804   6                                                      {
1805   7                                                              write_date(logolink1[num]);//显示提示
1806   7                                                              delay(2);
1807   7                                                      }
1808   6                                                      delays();
1809   6                                                      delays500ms();
1810   6                                                      zhenzhuan=1; //open win test
1811   6                                                      for(i = 0 ; i<20; i++)
1812   6                                                      {
1813   7                                                              Usart_Receive[i]=' ';
1814   7                                                      }
1815   6                                                      break;                                                                  //test
1816   6                                              }
1817   5                                              else if(Usart_Receive[7]=='2' || Usart_Receive[7]=='2'-'0')//if 2bits data
1818   5                                              {                        
1819   6                                                      delays500ms();  
1820   6                                                      write_com(0x80);
1821   6                                                      for(num=0;num<16;num++)
1822   6                                                      {
1823   7                                                              write_date(logolink2[num]);//显示提示
1824   7                                                              delay(2);
1825   7                                                      }
1826   6                                                      delays();
1827   6                                                      delays500ms();
1828   6                                                      zhenzhuan=1;//open win test     
1829   6                                                      for(i=0;i<20;i++)                                                                               
1830   6                                                      {
1831   7                                                              Usart_Receive[i]=' ';
1832   7                                                      }
1833   6                                                      break;                                                     //test
1834   6                                              }
1835   5                                              else
1836   5                                              {                 
1837   6                                                      write_com(0x80);
1838   6                                                      for(num=0;num<16;num++)
1839   6                                                      {
1840   7                                                              write_date(Usart_Receive[num]);//显示提示
1841   7                                                              delay(2);
1842   7                                                      }
1843   6                                                      break;                                                          //test
1844   6                                              }
1845   5      
1846   5      
1847   5                                      }
1848   4                              }
1849   3      
1850   3                      }
1851   2              }
1852   1               
1853   1      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 31  

1854   1      }
1855          
1856          
1857          void main()//主函数
1858          {
1859   1      //  init();
1860   1      //  init1602();
1861   1      
1862   1        sudu=200;     //电要速度
1863   1        zhenzhuan=0;//上电关正转
1864   1        fanzhuan=1;//上电反转打开
1865   1        dsflj=1;
1866   1                              // 显示打开
1867   1      
1868   1        uptemp=38; //温度上限
1869   1        uphum=80;      //湿度上限
1870   1      
1871   1      
1872   1        upbrig=120; // 光控值
1873   1      
1874   1        dwbrig=10;//光控亮度下限
1875   1        kwbrig=180;//光控亮度上限 
1876   1        upsmo=85;
1877   1      
1878   1        opensw=1;
1879   1        closesw=1;
1880   1        keysw=1;
1881   1        menusw=1;
1882   1        second=0;
1883   1       
1884   1                      zhenfl=0;
1885   1                      fanfl=0;
1886   1      
1887   1      
1888   1                              brigfl=1;
1889   1                              dwbrigfl=1;
1890   1                              humfl=0;
1891   1      
1892   1       adc0 = ADC0832(1,0);  //差分模式，CH0-CH1
1893   1       adc1 = ADC0832(1,1);  //差分模式，CH0-CH1
1894   1      
1895   1      
1896   1      
1897   1      
1898   1       hour=12;
1899   1       minit=5;
1900   1       secon=10; // 系统时间    这些值可以按键修改
1901   1      
1902   1      
1903   1      ONhour=12;      // 自动开窗时间  为了方便演示 设定 一分钟后开 这些值可以按键修改
1904   1      ONminit=6;
1905   1      ONsecon=10;
1906   1      
1907   1      
1908   1      OFhour=12;      // 自动关窗时间 为了方便演示 设定 一分钟后关 这些值可以按键修改
1909   1      OFminit=7;
1910   1      OFsecon=10;
1911   1      
1912   1      
1913   1        //esp8266
1914   1              kaiguan=0;
1915   1              InitUART();
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 32  

1916   1              init1602();
1917   1              
1918   1              open8266();//一次命令测试
1919   1      
1920   1              //esp8266 end   
1921   1      
1922   1      
1923   1      
1924   1              while(1)//大循环
1925   1      
1926   1              {
1927   2        
1928   2               
1929   2               
1930   2                  
1931   2      
1932   2      keyscn();
1933   2      setmoto();
1934   2      
1935   2      
1936   2      
1937   2      if (dsflj==1 )
1938   2      {
1939   3      
1940   3       //get_temp(); //SHT10调用
1941   3      //cal_wet();//SHT10调用
1942   3      
1943   3      RH(); //DHT11 调用
1944   3         
1945   3       //  U8T_data_H= SENSOR[k].temp;//SHT10调用
1946   3       //  U8RH_data_H=SENSOR[k].wet;//SHT10调用       
1947   3               
1948   3               
1949   3      TEMPHRDSPLAY(); 
1950   3      
1951   3      
1952   3      
1953   3       
1954   3      
1955   3       
1956   3      
1957   3      
1958   3      
1959   3      
1960   3       
1961   3      adc0 = ADC0832(1,0);  //差分模式，CH0-CH1 
1962   3      SMOGDSPLAY();
1963   3      
1964   3      adc1 = ADC0832(1,1);  //差分模式，CH0-CH1
1965   3      BRDSPLAY(); 
1966   3       
1967   3      
1968   3      
1969   3      
1970   3      
1971   3      
1972   3      
1973   3      
1974   3              if(fanfl==1)
1975   3              {
1976   4      
1977   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 33  

1978   4           if(adc1> kwbrig )//如果际亮度小与设定值 关窗
1979   4       {
1980   5      
1981   5        zhenzhuan=1;
1982   5      
1983   5      
1984   5      } 
1985   4         
1986   4         
1987   4         
1988   4         
1989   4         
1990   4               
1991   4         if(Im[2]==0x40)
1992   4               
1993   4      {
1994   5       Im[2]=0x00;
1995   5      zhenzhuan=1;
1996   5      
1997   5      }
1998   4      
1999   4      
2000   4      
2001   4      
2002   4         second=0;
2003   4      
2004   4       if(U8T_data_H>uptemp )//如果际温度大与设定值 开窗
2005   4       {
2006   5      
2007   5       zhenzhuan=1;
2008   5       
2009   5       }
2010   4       
2011   4      
2012   4      
2013   4       if(adc0>upsmo )//如果际温度大与设定值 开窗
2014   4       {
2015   5      
2016   5       zhenzhuan=1;
2017   5       
2018   5       }
2019   4      
2020   4      
2021   4        
2022   4      
2023   4      
2024   4      
2025   4      
2026   4      
2027   4      
2028   4      
2029   4      
2030   4      
2031   4      
2032   4      
2033   4      
2034   4      
2035   4      }
2036   3      
2037   3              if(zhenfl==1)
2038   3              {
2039   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 34  

2040   4                 if(Im[2]==0x44)
2041   4               
2042   4      {
2043   5      Im[2]=0x00;
2044   5      fanzhuan=1;
2045   5      
2046   5      }
2047   4      
2048   4      
2049   4              second=0;
2050   4       if(U8RH_data_H>uphum )//如果际湿度大与设定值 关窗
2051   4       {
2052   5      
2053   5       fanzhuan=1;
2054   5        brigfl=0;
2055   5        dwbrigfl=0;
2056   5        
2057   5        }
2058   4      
2059   4      
2060   4          if(adc1<dwbrig )//如果际亮度小与设定值 关窗
2061   4       {
2062   5      
2063   5      
2064   5      fanzhuan=1;
2065   5      }
2066   4        
2067   4      
2068   4      
2069   4      
2070   4      
2071   4      
2072   4        
2073   4      
2074   4      
2075   4       
2076   4      if(IR==0)       
2077   4              {
2078   5                 delay(10);
2079   5      
2080   5                  
2081   5                      if(IR==0)
2082   5                      {
2083   6                      //while(!IR);   
2084   6                        befl=1;
2085   6                         ET2=1; 
2086   6                        fanzhuan=1;
2087   6                        con=0;
2088   6                                                                              
2089   6                       } 
2090   5      
2091   5                        
2092   5      
2093   5      
2094   5                 }
2095   4      
2096   4      
2097   4      
2098   4      
2099   4       
2100   4      
2101   4      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 35  

2102   4      
2103   4        
2104   4      
2105   4      
2106   4      }
2107   3      
2108   3      
2109   3      
2110   3      
2111   3       
2112   3      
2113   3      
2114   3       
2115   3                              if(dec==0)      
2116   3              {
2117   4                 delay(10);
2118   4      
2119   4                  
2120   4                      if(dec==0)
2121   4                      {
2122   5                      while(!dec);                                                            
2123   5                       befl=0;
2124   5                       BEEP=1; 
2125   5                        
2126   5      
2127   5                       } 
2128   4      
2129   4      
2130   4                 }
2131   3         
2132   3      
2133   3      
2134   3                              
2135   3                      
2136   3      
2137   3      
2138   3      
2139   3      
2140   3      
2141   3      
2142   3      
2143   3              DSdat=secon;
2144   3                      write_com(0x80+14);
2145   3                      write_sfm();
2146   3      
2147   3                      DSdat=minit;
2148   3                  write_com(0x80+11);
2149   3                  write_sfm();
2150   3      
2151   3                      DSdat=hour;
2152   3              write_com(0x80+0x08);
2153   3                      write_sfm();
2154   3      
2155   3      
2156   3      
2157   3      
2158   3      
2159   3      
2160   3      
2161   3      
2162   3      
2163   3      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 36  

2164   3      
2165   3      
2166   3      
2167   3      
2168   3      }
2169   2      
2170   2      
2171   2      }
2172   1      
2173   1      
2174   1      }
2175           
2176          
2177          
2178          
2179          
2180          
2181          
2182          
2183           
2184          //定时器2中断
2185          timer2() interrupt 5 
2186          {
2187   1          TF2=0; //!!!注意!!! 定时器2必须由软件对溢出标志位清零，硬件不能清零，这里与定时器0和定时器1不同!!!
2188   1       
2189   1      
2190   1              count0++;
2191   1              con++;
2192   1      
2193   1              if(count0==15)
2194   1              {
2195   2                      count0=0;
2196   2              second++;
2197   2              }       
2198   1                      
2199   1                              
2200   1                      
2201   1           if(befl==1)
2202   1         {
2203   2                      if(con==20)
2204   2              {
2205   3                      con=0;
2206   3              BEEP=~BEEP;
2207   3                      
2208   3                      
2209   3                              
2210   3              }       
2211   2          
2212   2              }
2213   1       
2214   1              
2215   1      
2216   1      
2217   1      
2218   1      }
2219             
2220          
2221          
2222          
2223            void time0(void) interrupt 1 using 1          //定时中断子程序
2224          {
2225   1              TH0=0X3C;                                                       //重赋初值
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 37  

2226   1              TL0=0XBA;
2227   1      
2228   1        
2229   1      
2230   1      
2231   1      
2232   1      
2233   1      }
2234          
2235          
2236          
2237          
2238          
2239            //*********************************中断服务函数**************************************
2240          void  time0_int(void) interrupt 3 
2241          {
2242   1      
2243   1        
2244   1              TH0=0X3C;                                                       //重赋初值
2245   1              TL0=0XBA;               //定时初值
2246   1              TR1=1;
2247   1              time++;
2248   1       
2249   1                 
2250   1              if(time==20)
2251   1              {
2252   2                      time=0;
2253   2              secon++;        
2254   2                      
2255   2                  
2256   2                 
2257   2      
2258   2      
2259   2              }
2260   1              
2261   1                      
2262   1              if(secon==60)
2263   1              {
2264   2                      secon=0;
2265   2              minit++;
2266   2              
2267   2                              
2268   2                              
2269   2              }       
2270   1          
2271   1              
2272   1              if(minit==60)
2273   1              {
2274   2                      minit=0;
2275   2              hour++; 
2276   2                              if(hour==24)
2277   2              {
2278   3                      hour=0;
2279   3          }   
2280   2      
2281   2                
2282   2                      
2283   2      
2284   2                  
2285   2              }       
2286   1      
2287   1      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 38  

2288   1              
2289   1      
2290   1      
2291   1      
2292   1      
2293   1      
2294   1      
2295   1       
2296   1              if(fanfl==1)
2297   1              {
2298   2      
2299   2       
2300   2      
2301   2      
2302   2      
2303   2        if((ONhour==hour)&&(ONminit==minit)&&(ONsecon==secon))//定时开窗
2304   2        {
2305   3                              
2306   3      
2307   3      
2308   3       zhenzhuan=1;
2309   3      
2310   3       }
2311   2                       
2312   2      }
2313   1      
2314   1      
2315   1      
2316   1      
2317   1      
2318   1      
2319   1              if(zhenfl==1)
2320   1              {
2321   2      
2322   2      
2323   2      
2324   2        if((hour==OFhour)&&(minit==OFminit)&&(secon==OFsecon)) //定时关窗
2325   2        {
2326   3                              
2327   3      
2328   3      
2329   3       fanzhuan=1;
2330   3      
2331   3      
2332   3      
2333   3      
2334   3      }
2335   2        
2336   2      
2337   2      }
2338   1      
2339   1      
2340   1      
2341   1      
2342   1      
2343   1      
2344   1      
2345   1      
2346   1      
2347   1      
2348   1      
2349   1      
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 39  

2350   1       
2351   1      
2352   1      
2353   1      
2354   1      
2355   1      
2356   1      
2357   1      }
2358          
2359          
2360          
2361          
2362          //*********************************中断服务函数**************************************
2363          // 遥控 解码 函数 接收头 接外部 中断口 P3.3
2364          /************************************************************************/      
2365          //外部中断解码程序
2366          void intersvr1(void) interrupt 2 using 1
2367          {
2368   1          Tc=TH0*256+TL0; //定时器清空只记TC 值                                              //提取中断时间间隔
             -背
2369   1          TH0=0; 
2370   1          TL0=0;              //定时中断重新置零
2371   1      
2372   1              if((Tc>Imin)&&(Tc<Imax))//启动码判定 两个时间对比0.9MS  
2373   1              {  
2374   2              m=0;
2375   2              f=1;
2376   2              return;
2377   2              }       //找到启始码
2378   1              
2379   1              if(f==1)
2380   1              {
2381   2              if(Tc>Inum1&&Tc<Inum3) //判定是0该还是1 是0 1.125MS 是1  2.25MS
2382   2                      {
2383   3                              Im[m/8]=Im[m/8]>>1|0x80; m++;  //存0
2384   3                      }
2385   2                      if(Tc>Inum2&&Tc<Inum1) 
2386   2              {
2387   3                              Im[m/8]=Im[m/8]>>1; m++; //     存1
2388   3                      }
2389   2                      if(m==32)       //32位存储完毕
2390   2                      {
2391   3                              m=0;  
2392   3                              f=0;
2393   3                              if(Im[2]==~Im[3])  //反码检查
2394   3                              {        
2395   4                                      IrOK=1;         //OK 完成
2396   4                              }
2397   3                              else IrOK=0;   //取码完成后判断读码是否正确
2398   3                      }
2399   2                      //准备读下一码
2400   2              }
2401   1              
2402   1      }
2403          /************************************************************************/
2404          //************zheng 0X45; stop  0X46; fan  0X47   aut  0X43;


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5725    ----
   CONSTANT SIZE    =    364    ----
   XDATA SIZE       =     40    ----
C51 COMPILER V9.00   WIN                                                                   03/27/2019 13:48:19 PAGE 40  

   PDATA SIZE       =    102       2
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     70    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE WINDOW
OBJECT MODULE PLACED IN window.OBJ
COMPILER INVOKED BY: E:\Keil4\C51\BIN\C51.EXE window.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <dht11.h> //温湿度库函数
   3          #include <adc0832.h> //AD转换库函数
   4          #include <esp8266.h>
   5          
   6          sbit menu=P2^5; //主功能键      
   7          sbit add=P2^4;//加键            
   8          sbit dec=P2^3;// 减键
   9          sbit open=P2^6;// 手动 开
  10          sbit close=P2^7;// 手动 关      
  11          sbit IR=P3^5; //红外感 应
  12          sbit BEEP=P3^1;// 报警
  13          #define MOTORSTEP P1                    //定义P1口为步进电机驱动端口     
  14          
  15          uchar data dsflj,kval,lofl,menusw,con,befl,zhenfl,fanfl,brigfl;// 各种变量标记 正反转标记
  16          uint data sudu,dwbrigfl,humfl;  //电机速度 //光度下限/湿度标记
  17          uchar data count0,second,zhenzhuan,fanzhuan,timeflg,opensw,closesw,keysw;//时钟变量 正反转 变量 
  18          uint data adc0,adc1;
  19          uint data upbrig,dwbrig,kwbrig,uphum,uptemp,upsmo; // 光控下限 温度上限
  20          uint i;//esp8266
  21          
  22          uint data hour,minit,secon,DSdat,VAldat ,time;//时钟变量
  23          
  24          uint data ONhour,ONminit,ONsecon; // 开窗时间变量
  25          uint data OFhour,OFminit,OFsecon; // 关窗时间变量
  26          uchar U8T_data_H,U8RH_data_H;
  27          
  28          
  29          #define Imax 14000    //晶振为11.0592时的取值
  30          #define Imin 8000
  31          #define Inum1 1450
  32          #define Inum2 700 
  33          #define Inum3 3000 
  34          
  35          uchar idata f=0;
  36          uchar idata Im[4]={0x00,0x00,0x00,0x00}; // 遥控码存储空间
  37          uchar idata show[2]={0,0};  // 变量申明
  38          ulong idata m,Tc;         // 变量申明
  39          uchar idata IrOK;               // 变量申明
  40          
  41          
  42          void delay(uint z);// 开窗时间变量
  43          void write_rvalue(); // 显示函数
  44          void open8266();
  45          void init2();
  46          
  47          
  48          void delaymoto()                                        //步进电机每一步间延迟函数
  49          {       
  50   1              uint y=sudu;     //sudu越大->转动越慢
  51   1              while(y--);
  52   1      }
  53          
  54          
  55          
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 2   

  56          uchar code FFW[]={0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09}; //步进电机驱动值数组
  57          
  58          uchar code REV[]={0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01}; //步进电机驱动值数组
  59          
  60          num1 [4] =    {0x00,0x00,0x00,0x00,};                           
  61          num2 [4] =    {0x00,0x00,0x00,0x00,};                    
  62          num3 [4] =    {0x00,0x00,0x00,0x00,};              
  63          num4 [4] =    {0x00,0x00,0x00,0x00,};
  64          num5 [4] =    {0x00,0x00,0x00,0x00,};   // AD转换变量组组
  65          
  66          
  67          
  68          
  69          
  70          
  71          
  72          
  73          
  74            void SETP_MOTOR_FFW()  //反转
  75          {
  76   1                         uint i=0;
  77   1      
  78   1                      for(i=0;i<8;i++) //8步一个循环
  79   1                              {
  80   2                                      MOTORSTEP=FFW[i]; //取值赋给P1驱动口
  81   2                                      delaymoto(); 
  82   2                              }
  83   1      
  84   1       }
  85          
  86          void SETP_MOTOR_REV()  //正转
  87          {
  88   1       
  89   1      
  90   1          uint i=0;
  91   1      
  92   1                      for(i=0;i<8;i++) //8步一个循环
  93   1                              {
  94   2                                      MOTORSTEP=REV[i]; //取值赋给P1驱动口
  95   2                                      delaymoto(); 
  96   2                              }
  97   1      
  98   1      }
  99          
 100          
 101          void write_sfm() // 拆分 个位 十位显示
 102          
 103          {       uchar shi ,ge;
 104   1      
 105   1              shi=DSdat/10;
 106   1              ge=DSdat%10;
 107   1              
 108   1              write_date(0x30+shi);
 109   1              write_date(0x30+ge);    
 110   1      
 111   1      
 112   1      }
 113          
 114          
 115          
 116          
 117          
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 3   

 118          
 119          
 120          void keyscn()//按键扫描函数
 121          {
 122   1        uchar num; //局部变量
 123   1              
 124   1      
 125   1              //在非设置模式时，加键按下可进入WIFI控制模式
 126   1      //      if(keysw==1)//如果当前开关窗键可用
 127   1      //      {
 128   1                      if(add==0)       //如果加键按下
 129   1                      {
 130   2                              //保存现场--begin
 131   2                              TR1=0;
 132   2                              ET0=0;
 133   2                              ET1=0;
 134   2      
 135   2                              TR2=0;
 136   2                              ET2=0;
 137   2                              IT1=0;
 138   2      
 139   2                              TR0=0;
 140   2                              EX1=0;
 141   2                              //保存现场--end
 142   2      
 143   2                              InitUART();//init timer1
 144   2                              open8266();//一次命令测试       
 145   2                                      
 146   2                              //恢复现场: begin
 147   2                              TR1=0;//关闭TR1
 148   2                              PCON=0x30;//倍率还原(地址0x87)     ResetValue=00X1 0000             debug 2019年4月9日 09:13:43
 149   2                              SCON=0x00;//串口接收禁止(地址0x98)        
 150   2                              ES=0;//串口中断禁止
 151   2                              EA=0;//中断关
 152   2                              init2();//再次开启所有时钟，恢复待机模式           
 153   2                              //恢复现场: end
 154   2                      }
 155   1      //      }
 156   1              
 157   1                                              
 158   1              
 159   1              
 160   1                                              
 161   1                                              
 162   1      if(keysw==1)
 163   1      {
 164   2       if(opensw==1)
 165   2       {
 166   3      if(open==0)      // 如果open键被按下，手动开窗
 167   3              {
 168   4                        write_com(0x80);
 169   4      
 170   4                              for(num=0;num<16;num++)//显示提示语
 171   4                      {
 172   5                              write_date(logo5[num]);
 173   5                              delay(2);
 174   5                      }
 175   4      
 176   4      
 177   4                        write_com(0x80+0x40);
 178   4      
 179   4                              for(num=0;num<16;num++)//显示提示语
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 4   

 180   4                      {
 181   5                              write_date(logo10[num]);
 182   5                              delay(2);
 183   5                      }
 184   4      
 185   4      
 186   4      
 187   4                       
 188   4                       
 189   4                       closesw=1;     // 已打开标记
 190   4                   delay(10);
 191   4                      if(open==0)                               //防抖，确认open键被按下
 192   4                      {
 193   5                      while(!open);                   //待open键被放开，解除阻塞
 194   5                      zhenzhuan=1;// 正转 开启
 195   5                      fanzhuan=0;      // 返转关闭
 196   5                      second=0;// 秒清零 步进电机 会停
 197   5                      keysw=0;
 198   5                      menusw=0;
 199   5                       }
 200   4               
 201   4                      } 
 202   3               
 203   3       }
 204   2      
 205   2      
 206   2        if(closesw==1)//如果窗户是打开的
 207   2        {
 208   3       if(close==0)//按下手动关
 209   3              {
 210   4      
 211   4                 write_com(0x80);
 212   4      
 213   4                              for(num=0;num<16;num++)//显示提示语
 214   4                      {
 215   5                              write_date(logo6[num]);
 216   5                              delay(2);
 217   5                      }
 218   4      
 219   4                                write_com(0x80+0x40);
 220   4      
 221   4                              for(num=0;num<16;num++)
 222   4                      {
 223   5                              write_date(logo10[num]);//显示提示语
 224   5                              delay(2);
 225   5                      }
 226   4      
 227   4      
 228   4                       
 229   4                   delay(10);
 230   4                      if(close==0)                     //如果close键被按下
 231   4                      {
 232   5                      while(!close);                                                          //待close键被放开
 233   5                      zhenzhuan=0;  //正转关
 234   5                      fanzhuan=1;     // 反转 开启
 235   5                      second=0;       // 定时清零
 236   5                      keysw=0; // 标记请零
 237   5                       menusw=0;
 238   5                       }
 239   4               
 240   4                      } 
 241   3      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 5   

 242   3       }
 243   2      
 244   2      }
 245   1      
 246   1      
 247   1       if(menusw==1)//如果窗户运行完毕
 248   1      {
 249   2        if(menu==0)// 如果主功能键menu被按下
 250   2              {
 251   3      
 252   3                      lofl=1; //字幕载入
 253   3      
 254   3                      
 255   3      
 256   3                   delay(10); //延时消抖动
 257   3                      if(menu==0)
 258   3                      {
 259   4                      while(!menu);//松手检测
 260   4                       dsflj=0;// 关主页显示
 261   4                       kval++; // 按键变量++
 262   4                       keysw=0;//不允许手动 开窗  和关窗
 263   4                       }
 264   3                       } 
 265   2      
 266   2                       
 267   2      
 268   2      //*************************************************************************8
 269   2      
 270   2        if(kval==1)  // 如果变量==1  进入时间设定
 271   2      
 272   2       {
 273   3        
 274   3        if(lofl==1)
 275   3        {
 276   4       write_com(0x80);
 277   4      
 278   4                              for(num=0;num<16;num++)
 279   4                      {
 280   5                              write_date(logo12[num]);//显示提示语
 281   5                              delay(2);
 282   5      
 283   5                      
 284   5                      }
 285   4      
 286   4      
 287   4      
 288   4                 write_com(0x80+0x40);
 289   4      
 290   4                              for(num=0;num<16;num++) //显示提示语
 291   4                      {
 292   5                              write_date(logo9[num]);
 293   5                              delay(2);
 294   5      
 295   5                              lofl=0;
 296   5                      }
 297   4      
 298   4      
 299   4      
 300   4      
 301   4                      DSdat=hour;
 302   4              write_com(0x80+8);      // 刷新 设定时间
 303   4                      write_sfm();
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 6   

 304   4      
 305   4      
 306   4             
 307   4                      DSdat=minit;
 308   4                  write_com(0x80+11);// 刷新 设定时间
 309   4                  write_sfm();
 310   4      
 311   4                       DSdat=secon;
 312   4                      write_com(0x80+14);     // 刷新 设定时间
 313   4                      write_sfm();
 314   4      
 315   4      
 316   4      
 317   4      }
 318   3      
 319   3      
 320   3       }
 321   2      
 322   2      
 323   2      
 324   2      //uint hour,minit,secon;
 325   2      
 326   2         if(kval==2)//如果变量=2 进入小时设定
 327   2      
 328   2       {DSdat=hour;     // 刷新显示小时
 329   3        
 330   3        
 331   3        write_com(0x40+0x40+8);// 显示坐标
 332   3        write_com(0x0e);
 333   3                                                 // 开关标
 334   3      
 335   3        
 336   3      if(add==0)// 如果加键按下
 337   3      
 338   3      {
 339   4      
 340   4      while(!add); // 松手检测
 341   4       
 342   4      
 343   4      hour++; //小时++
 344   4      
 345   4      DSdat=hour; //送显示
 346   4      write_sfm(); // 拆分
 347   4      if(hour==24)  //
 348   4      {hour=0;}
 349   4      
 350   4      
 351   4      
 352   4      }
 353   3      
 354   3      
 355   3      
 356   3      
 357   3      
 358   3       if( dec==0) // 如果减键按下
 359   3      
 360   3      {
 361   4      
 362   4      while(! dec);// 松手检测
 363   4       
 364   4      
 365   4      hour--;  //小时--
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 7   

 366   4      DSdat=hour;
 367   4      write_sfm(); //拆分限位
 368   4      if(hour==0)//限位
 369   4      {hour=23;}
 370   4      
 371   4      
 372   4      
 373   4      
 374   4      }
 375   3      
 376   3       }
 377   2      
 378   2      
 379   2      
 380   2      
 381   2      
 382   2      
 383   2      
 384   2       //**************************以下时 分钟设 定 秒钟设定 和上面小时一样
 385   2       //只是就量不一样 不作注释*******************************************
 386   2       //********************************************************************
 387   2       
 388   2         if(kval==3)
 389   2      
 390   2       {
 391   3      
 392   3      
 393   3      DSdat=minit;
 394   3      
 395   3        write_com(0x40+0x40+11);
 396   3        write_com(0x0e);
 397   3      
 398   3      
 399   3        
 400   3      if(add==0)
 401   3      
 402   3      {
 403   4      
 404   4      while(!add);
 405   4       
 406   4      
 407   4      minit++;
 408   4      
 409   4      DSdat=minit;
 410   4      write_sfm();
 411   4      if(minit==60)
 412   4      {minit=0;}
 413   4      
 414   4      
 415   4      
 416   4      }
 417   3      
 418   3      
 419   3      
 420   3      
 421   3      
 422   3       if( dec==0)
 423   3      
 424   3      {
 425   4      
 426   4      while(! dec);
 427   4       
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 8   

 428   4      
 429   4      minit--;
 430   4      
 431   4      DSdat=minit;
 432   4      write_sfm();
 433   4      if(minit==0)
 434   4      {minit=59;}
 435   4      
 436   4      
 437   4      
 438   4      }
 439   3      
 440   3       }
 441   2      
 442   2      
 443   2      
 444   2      
 445   2      
 446   2      
 447   2      
 448   2      
 449   2      
 450   2      
 451   2      
 452   2      
 453   2      
 454   2       
 455   2         if(kval==4)
 456   2      
 457   2       { 
 458   3       
 459   3       
 460   3       DSdat=secon;
 461   3        
 462   3        write_com(0x40+0x40+14);
 463   3        write_com(0x0e);
 464   3      
 465   3      
 466   3        
 467   3      if(add==0)
 468   3      
 469   3      {
 470   4      
 471   4      while(!add);
 472   4       
 473   4      
 474   4      secon++;
 475   4      
 476   4      DSdat=secon;
 477   4      write_sfm();
 478   4      if(secon==60)
 479   4      {secon=0;}
 480   4      
 481   4      
 482   4      
 483   4      }
 484   3      
 485   3      
 486   3      
 487   3      
 488   3      
 489   3       if( dec==0)
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 9   

 490   3      
 491   3      {
 492   4      
 493   4      while(! dec);
 494   4       
 495   4      
 496   4      secon--;
 497   4      
 498   4      DSdat=secon;
 499   4      write_sfm();
 500   4      if(secon==0)
 501   4      {secon=59;}
 502   4      
 503   4      
 504   4      
 505   4      }
 506   3      
 507   3       }
 508   2      
 509   2      
 510   2      //uint ONhour,ONminit,ONsecon;
 511   2      //uint OFhour,OFminit,OFsecon;
 512   2      
 513   2       
 514   2      
 515   2       //**************************以下 开窗时  小时 分钟设 定 秒钟设定 和上面小时一样
 516   2       //只是就量不一样 不作注释*******************************************
 517   2       //**************
 518   2      
 519   2      //*************************************设定开时****************************************
 520   2       
 521   2         if(kval==5)
 522   2      
 523   2       {
 524   3        
 525   3         if(lofl==1)
 526   3        {
 527   4       write_com(0x80);
 528   4      
 529   4                              for(num=0;num<16;num++)
 530   4                      {
 531   5                              write_date(logo13[num]);
 532   5                              delay(2);
 533   5      
 534   5                      
 535   5                      }
 536   4      
 537   4      
 538   4      
 539   4                 write_com(0x80+0x40);
 540   4      
 541   4                              for(num=0;num<16;num++)
 542   4                      {
 543   5                              write_date(logo9[num]);
 544   5                              delay(2);
 545   5      
 546   5                      
 547   5                      }
 548   4      
 549   4      
 550   4      
 551   4                      DSdat=ONhour;
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 10  

 552   4              write_com(0x80+8);
 553   4                      write_sfm();
 554   4      
 555   4      
 556   4                      DSdat=ONminit;
 557   4                  write_com(0x80+11);
 558   4                  write_sfm();
 559   4      
 560   4      
 561   4             DSdat=ONsecon;
 562   4                      write_com(0x80+14);
 563   4                      write_sfm();
 564   4      
 565   4              
 566   4                      
 567   4      
 568   4      
 569   4                      lofl=0;
 570   4      
 571   4      
 572   4      
 573   4      
 574   4      
 575   4      }
 576   3      
 577   3      
 578   3      
 579   3      
 580   3      
 581   3      }
 582   2      
 583   2       
 584   2      
 585   2      
 586   2        if(kval==6)
 587   2      
 588   2       {
 589   3        
 590   3        write_com(0x80+0x08);
 591   3        write_com(0x0e);
 592   3      
 593   3      
 594   3        
 595   3      if(add==0)
 596   3      
 597   3      {
 598   4      
 599   4      while(!add);
 600   4       
 601   4      
 602   4      ONhour++;
 603   4      
 604   4      DSdat=ONhour;
 605   4      write_sfm();
 606   4      if(ONhour==24)
 607   4      {ONhour=0;}
 608   4      
 609   4      
 610   4      
 611   4      }
 612   3      
 613   3      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 11  

 614   3      
 615   3      
 616   3      
 617   3       if( dec==0)
 618   3      
 619   3      {
 620   4      
 621   4      while(! dec);
 622   4       
 623   4      
 624   4      ONhour--;
 625   4      
 626   4      DSdat=ONhour;
 627   4      write_sfm();
 628   4      if(ONhour==0)
 629   4      {ONhour=23;}
 630   4      
 631   4      
 632   4      
 633   4      }
 634   3      
 635   3       }
 636   2      
 637   2      
 638   2      
 639   2      
 640   2      
 641   2      
 642   2         if(kval==7)
 643   2      
 644   2       {
 645   3        
 646   3        write_com(0x40+0x40+11);
 647   3        write_com(0x0e);
 648   3      
 649   3      
 650   3        
 651   3      if(add==0)
 652   3      
 653   3      {
 654   4      
 655   4      while(!add);
 656   4       
 657   4      
 658   4      ONminit++;
 659   4      
 660   4      DSdat=ONminit;
 661   4      write_sfm();
 662   4      if(ONminit==60)
 663   4      {ONminit=0;}
 664   4      
 665   4      
 666   4      
 667   4      }
 668   3      
 669   3      
 670   3      
 671   3      
 672   3      
 673   3       if( dec==0)
 674   3      
 675   3      {
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 12  

 676   4      
 677   4      while(! dec);
 678   4       
 679   4      
 680   4      ONminit--;
 681   4      
 682   4      DSdat=ONminit;
 683   4      write_sfm();
 684   4      if(ONminit==0)
 685   4      {ONminit=59;}
 686   4      
 687   4      
 688   4      
 689   4      }
 690   3      
 691   3       }
 692   2      
 693   2      
 694   2      
 695   2      
 696   2      
 697   2      
 698   2        if(kval==8)
 699   2      
 700   2       {
 701   3        
 702   3        write_com(0x40+0x40+14);
 703   3        write_com(0x0e);
 704   3      
 705   3      
 706   3        
 707   3      if(add==0)
 708   3      
 709   3      {
 710   4      
 711   4      while(!add);
 712   4       
 713   4      
 714   4      ONsecon++;
 715   4      
 716   4      DSdat=ONsecon;
 717   4      write_sfm();
 718   4      if(ONsecon==60)
 719   4      {ONsecon=0;}
 720   4      
 721   4      
 722   4      
 723   4      }
 724   3      
 725   3      
 726   3      
 727   3      
 728   3      
 729   3       if( dec==0)
 730   3      
 731   3      {
 732   4      
 733   4      while(! dec);
 734   4       
 735   4      
 736   4      ONsecon--;
 737   4      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 13  

 738   4      DSdat=ONsecon;
 739   4      write_sfm();
 740   4      if(ONsecon==0)
 741   4      {ONsecon=59;}
 742   4      
 743   4      
 744   4      
 745   4      }
 746   3      
 747   3       }
 748   2       
 749   2      
 750   2       //**************************以下 关窗时  小时 分钟设 定 秒钟设定 和上面小时一样
 751   2       //只是就量不一样 不作注释*******************************************
 752   2       //**************
 753   2      
 754   2      
 755   2      //**************************************设定关时间**************************************
 756   2              
 757   2              
 758   2       
 759   2         if(kval==9)
 760   2      
 761   2       {
 762   3        
 763   3         if(lofl==1)
 764   3        {
 765   4       write_com(0x80);
 766   4      
 767   4                              for(num=0;num<16;num++)
 768   4                      {
 769   5                              write_date(logo14[num]);
 770   5                              delay(2);
 771   5      
 772   5                      
 773   5                      }
 774   4      
 775   4      
 776   4      
 777   4                 write_com(0x80+0x40);
 778   4      
 779   4                              for(num=0;num<16;num++)
 780   4                      {
 781   5                              write_date(logo9[num]);
 782   5                              delay(2);
 783   5      
 784   5                              lofl=0;
 785   5                      }
 786   4      
 787   4      
 788   4                      DSdat=OFhour;
 789   4              write_com(0x80+8);
 790   4                      write_sfm();
 791   4      
 792   4      
 793   4                      DSdat=OFminit;
 794   4                  write_com(0x80+11);
 795   4                  write_sfm();
 796   4      
 797   4                      
 798   4      
 799   4              DSdat=OFsecon;
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 14  

 800   4                      write_com(0x80+14);
 801   4                      write_sfm();
 802   4      
 803   4                      
 804   4      
 805   4      }
 806   3      
 807   3      
 808   3      
 809   3      
 810   3      
 811   3      }       
 812   2              
 813   2              
 814   2              
 815   2              
 816   2              
 817   2              
 818   2              
 819   2              
 820   2                      
 821   2       if(kval==10)
 822   2      
 823   2       {
 824   3        
 825   3        write_com(0x80+0x08);
 826   3        write_com(0x0e);
 827   3      
 828   3      
 829   3        
 830   3      if(add==0)
 831   3      
 832   3      {
 833   4      
 834   4      while(!add);
 835   4       
 836   4      
 837   4      OFhour++;
 838   4      
 839   4      DSdat=OFhour;
 840   4      write_sfm();
 841   4      if(OFhour==24)
 842   4      {OFhour=0;}
 843   4      
 844   4      
 845   4      
 846   4      }
 847   3      
 848   3      
 849   3      
 850   3      
 851   3      
 852   3       if( dec==0)
 853   3      
 854   3      {
 855   4      
 856   4      while(! dec);
 857   4       
 858   4      
 859   4      OFhour--;
 860   4      
 861   4      DSdat=OFhour;
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 15  

 862   4      write_sfm();
 863   4      if(OFhour==0)
 864   4      {OFhour=23;}
 865   4      
 866   4      
 867   4      
 868   4      }
 869   3      
 870   3       }
 871   2      
 872   2      
 873   2      
 874   2      
 875   2      
 876   2      
 877   2         if(kval==11)
 878   2      
 879   2       {
 880   3        
 881   3        write_com(0x40+0x40+11);
 882   3        write_com(0x0e);
 883   3      
 884   3      
 885   3        
 886   3      if(add==0)
 887   3      
 888   3      {
 889   4      
 890   4      while(!add);
 891   4       
 892   4      
 893   4      OFminit++;
 894   4      
 895   4      DSdat=OFminit;
 896   4      write_sfm();
 897   4      if(OFminit==60)
 898   4      {OFminit=0;}
 899   4      
 900   4      
 901   4      
 902   4      }
 903   3      
 904   3      
 905   3      
 906   3      
 907   3      
 908   3       if( dec==0)
 909   3      
 910   3      {
 911   4      
 912   4      while(! dec);
 913   4       
 914   4      
 915   4      OFminit--;
 916   4      
 917   4      DSdat=OFminit;
 918   4      write_sfm();
 919   4      if(OFminit==0)
 920   4      {OFminit=59;}
 921   4      
 922   4      
 923   4      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 16  

 924   4      }
 925   3      
 926   3       }
 927   2      
 928   2      
 929   2      
 930   2      
 931   2      
 932   2      
 933   2      
 934   2      
 935   2      
 936   2      
 937   2      
 938   2      
 939   2        if(kval==12)
 940   2      
 941   2       {
 942   3        
 943   3        write_com(0x40+0x40+14);
 944   3        write_com(0x0e);
 945   3      
 946   3      
 947   3        
 948   3      if(add==0)
 949   3      
 950   3      {
 951   4      
 952   4      while(!add);
 953   4       
 954   4      
 955   4      OFsecon++;
 956   4      
 957   4      DSdat=OFsecon;
 958   4      write_sfm();
 959   4      if(OFsecon==60)
 960   4      {OFsecon=0;}
 961   4      
 962   4      
 963   4      
 964   4      }
 965   3      
 966   3      
 967   3      
 968   3      
 969   3      
 970   3       if( dec==0)
 971   3      
 972   3      {
 973   4      
 974   4      while(! dec);
 975   4       
 976   4      
 977   4      OFsecon--;
 978   4      
 979   4      DSdat=OFsecon;
 980   4      write_sfm();
 981   4      if(OFsecon==0)
 982   4      {OFsecon=59;}
 983   4      
 984   4      
 985   4      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 17  

 986   4      }
 987   3      
 988   3       }
 989   2      
 990   2      
 991   2      
 992   2      
 993   2      
 994   2      
 995   2      
 996   2      
 997   2      
 998   2      
 999   2       
1000   2      
1001   2       //**************************以下 亮度会上设定  和上面小时一样
1002   2       //只是就量不一样 不作注释*******************************************
1003   2       //**************
1004   2      
1005   2      
1006   2        //********************************设定环境参数************************************
1007   2       
1008   2        if(kval==13)
1009   2      
1010   2       {
1011   3      
1012   3         write_com(0x0c);
1013   3      
1014   3         num4[4]=dwbrig;
1015   3         write_rvalue();
1016   3        if(lofl==1)
1017   3        {
1018   4       write_com(0x80);
1019   4      
1020   4                              for(num=0;num<16;num++)
1021   4                      {
1022   5                              write_date(logo7[num]);
1023   5                              delay(2);
1024   5      
1025   5                      
1026   5                      }
1027   4      
1028   4      
1029   4      
1030   4                 write_com(0x80+0x40);
1031   4      
1032   4                              for(num=0;num<16;num++)
1033   4                      {
1034   5                              write_date(logo9[num]);
1035   5                              delay(2);
1036   5      
1037   5                              lofl=0;
1038   5                      }
1039   4      
1040   4      
1041   4      }
1042   3      
1043   3      
1044   3          if(add==0)  
1045   3              {
1046   4                 delay(10);
1047   4      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 18  

1048   4                  
1049   4                      if(add==0)
1050   4                      {
1051   5                      while(!add);                                                            
1052   5                       dwbrig++;
1053   5                       num4[4]=dwbrig;
1054   5                       write_rvalue();
1055   5      
1056   5      
1057   5               if(dwbrig==250)
1058   5                {dwbrig=0;}
1059   5      
1060   5      
1061   5                       }
1062   4                       } 
1063   3      
1064   3      
1065   3      
1066   3                      if(dec==0)      
1067   3              {
1068   4                 delay(10);
1069   4      
1070   4                  
1071   4                      if(dec==0)
1072   4                      {
1073   5                      while(!dec);                                                            
1074   5                       dwbrig--;
1075   5                       num4[4]=dwbrig;
1076   5                       write_rvalue();
1077   5      
1078   5      
1079   5               if(dwbrig==0)
1080   5                {dwbrig=250;}
1081   5      
1082   5      
1083   5                       }
1084   4                       } 
1085   3      
1086   3      
1087   3       }
1088   2      
1089   2      
1090   2      
1091   2      
1092   2      
1093   2      
1094   2      
1095   2      
1096   2      
1097   2      
1098   2      
1099   2      //*********************************************************************
1100   2      
1101   2      
1102   2         //********************************设定环境参数************************************
1103   2       
1104   2        if(kval==14)
1105   2      
1106   2       {
1107   3      
1108   3         write_com(0x0c);
1109   3      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 19  

1110   3         num4[4]=kwbrig;
1111   3         write_rvalue();
1112   3        if(lofl==1)
1113   3        {
1114   4       write_com(0x80);
1115   4      
1116   4                              for(num=0;num<16;num++)
1117   4                      {
1118   5                              write_date(logo16[num]);
1119   5                              delay(2);
1120   5      
1121   5                      
1122   5                      }
1123   4      
1124   4      
1125   4      
1126   4                 write_com(0x80+0x40);
1127   4      
1128   4                              for(num=0;num<16;num++)
1129   4                      {
1130   5                              write_date(logo9[num]);
1131   5                              delay(2);
1132   5      
1133   5                              lofl=0;
1134   5                      }
1135   4      
1136   4      
1137   4      }
1138   3      
1139   3      
1140   3          if(add==0)  
1141   3              {
1142   4                 delay(10);
1143   4      
1144   4                  
1145   4                      if(add==0)
1146   4                      {
1147   5                      while(!add);                                                            
1148   5                       kwbrig++;
1149   5                       num4[4]=kwbrig;
1150   5                       write_rvalue();
1151   5      
1152   5      
1153   5               if(kwbrig==250)
1154   5                {kwbrig=0;}
1155   5      
1156   5      
1157   5                       }
1158   4                       } 
1159   3      
1160   3      
1161   3      
1162   3                      if(dec==0)      
1163   3              {
1164   4                 delay(10);
1165   4      
1166   4                  
1167   4                      if(dec==0)
1168   4                      {
1169   5                      while(!dec);                                                            
1170   5                       kwbrig--;
1171   5                       num4[4]=kwbrig;
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 20  

1172   5                       write_rvalue();
1173   5      
1174   5      
1175   5               if(kwbrig==0)
1176   5                {kwbrig=250;}
1177   5      
1178   5      
1179   5                       }
1180   4                       } 
1181   3      
1182   3      
1183   3       }
1184   2      
1185   2      
1186   2      
1187   2      
1188   2      
1189   2      
1190   2      
1191   2      
1192   2      
1193   2      
1194   2      
1195   2      
1196   2      
1197   2       
1198   2       //**************************以下 湿度会上设定  和上面小时一样
1199   2       //只是就量不一样 不作注释*******************************************
1200   2       //**************               
1201   2       if(kval==15)
1202   2      
1203   2       {
1204   3         num4[4]=uphum;
1205   3         write_rvalue();
1206   3        if(lofl==1)
1207   3        {
1208   4       write_com(0x80);
1209   4      
1210   4                              for(num=0;num<16;num++)
1211   4                      {
1212   5                              write_date(logo8[num]);
1213   5                              delay(2);
1214   5      
1215   5                      
1216   5                      }
1217   4      
1218   4      
1219   4      
1220   4                 write_com(0x80+0x40);
1221   4      
1222   4                              for(num=0;num<16;num++)
1223   4                      {
1224   5                              write_date(logo9[num]);
1225   5                              delay(2);
1226   5      
1227   5                              lofl=0;
1228   5                      }
1229   4      
1230   4      
1231   4      }
1232   3      
1233   3      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 21  

1234   3                 
1235   3      
1236   3                
1237   3      
1238   3      
1239   3      
1240   3      
1241   3          if(add==0)  
1242   3              {
1243   4                 delay(10);
1244   4      
1245   4                  
1246   4                      if(add==0)
1247   4                      {
1248   5                      while(!add);                                                            
1249   5                       uphum++;
1250   5                       num4[4]=uphum;
1251   5                       write_rvalue();
1252   5      
1253   5      
1254   5               if(uphum==100)
1255   5                {uphum=0;}
1256   5      
1257   5      
1258   5                       }
1259   4                       } 
1260   3      
1261   3      
1262   3      
1263   3                      if(dec==0)      
1264   3              {
1265   4                 delay(10);
1266   4      
1267   4                  
1268   4                      if(dec==0)
1269   4                      {
1270   5                      while(!dec);                                                            
1271   5                       uphum--;
1272   5                       num4[4]=uphum;
1273   5                       write_rvalue();
1274   5      
1275   5      
1276   5               if(uphum==0)
1277   5                {uphum=100;}
1278   5      
1279   5      
1280   5                       }
1281   4                       } 
1282   3      
1283   3      
1284   3       }
1285   2      
1286   2      
1287   2      
1288   2      
1289   2      
1290   2       
1291   2       //**************************以下 温度度会上设定  和上面小时一样
1292   2       //只是就量不一样 不作注释*******************************************
1293   2       //**************                               
1294   2       if(kval==16)
1295   2      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 22  

1296   2       {
1297   3         num4[4]=uptemp;
1298   3         write_rvalue();
1299   3        if(lofl==1)
1300   3        {
1301   4       write_com(0x80);
1302   4      
1303   4                              for(num=0;num<16;num++)
1304   4                      {
1305   5                              write_date(logo11[num]);
1306   5                              delay(2);
1307   5      
1308   5                      
1309   5                      }
1310   4      
1311   4      
1312   4      
1313   4                 write_com(0x80+0x40);
1314   4      
1315   4                              for(num=0;num<16;num++)
1316   4                      {
1317   5                              write_date(logo9[num]);
1318   5                              delay(2);
1319   5      
1320   5                              lofl=0;
1321   5                      }
1322   4      
1323   4      
1324   4      }
1325   3      
1326   3      
1327   3                 
1328   3      
1329   3                
1330   3      
1331   3      
1332   3      
1333   3      
1334   3          if(add==0)  
1335   3              {
1336   4                 delay(10);
1337   4      
1338   4                  
1339   4                      if(add==0)
1340   4                      {
1341   5                      while(!add);                                                            
1342   5                       uptemp++;
1343   5                       num4[4]=uptemp;
1344   5                       write_rvalue();
1345   5      
1346   5      
1347   5               if(uptemp==100)
1348   5                {uptemp=0;}
1349   5      
1350   5      
1351   5                       }
1352   4                       } 
1353   3      
1354   3      
1355   3      
1356   3                      if(dec==0)      
1357   3              {
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 23  

1358   4                 delay(10);
1359   4      
1360   4                  
1361   4                      if(dec==0)
1362   4                      {
1363   5                      while(!dec);                                                            
1364   5                       uptemp--;
1365   5                       num4[4]=uptemp;
1366   5                       write_rvalue();
1367   5      
1368   5      
1369   5               if(uptemp==0)
1370   5                {uptemp=100;}
1371   5      
1372   5      
1373   5                       }
1374   4                       } 
1375   3      
1376   3      
1377   3       }
1378   2      
1379   2      
1380   2      
1381   2      
1382   2      
1383   2       
1384   2      
1385   2       //**************************以下烟雾度会上设定  和上面小时一样
1386   2       //只是就量不一样 不作注释*******************************************
1387   2       //**************                               
1388   2       if(kval==17)
1389   2      
1390   2       {
1391   3         num4[4]=upsmo;
1392   3         write_rvalue();
1393   3        if(lofl==1)
1394   3        {
1395   4       write_com(0x80);
1396   4      
1397   4                              for(num=0;num<16;num++)
1398   4                      {
1399   5                              write_date(logo15[num]);
1400   5                              delay(2);
1401   5      
1402   5                      
1403   5                      }
1404   4      
1405   4      
1406   4      
1407   4                 write_com(0x80+0x40);
1408   4      
1409   4                              for(num=0;num<16;num++)
1410   4                      {
1411   5                              write_date(logo9[num]);
1412   5                              delay(2);
1413   5      
1414   5                              lofl=0;
1415   5                      }
1416   4      
1417   4      
1418   4      }
1419   3      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 24  

1420   3      
1421   3                 
1422   3      
1423   3                
1424   3      
1425   3      
1426   3      
1427   3      
1428   3          if(add==0)  
1429   3              {
1430   4                 delay(10);
1431   4      
1432   4                  
1433   4                      if(add==0)
1434   4                      {
1435   5                      while(!add);                                                            
1436   5                       upsmo++;
1437   5                       num4[4]=upsmo;
1438   5                       write_rvalue();
1439   5      
1440   5      
1441   5               if(upsmo==100)
1442   5                {upsmo=0;}
1443   5      
1444   5      
1445   5                       }
1446   4                       } 
1447   3      
1448   3      
1449   3      
1450   3                      if(dec==0)      
1451   3              {
1452   4                 delay(10);
1453   4      
1454   4                  
1455   4                      if(dec==0)
1456   4                      {
1457   5                      while(!dec);                                                            
1458   5                       upsmo--;
1459   5                       num4[4]=upsmo;
1460   5                       write_rvalue();
1461   5      
1462   5      
1463   5               if(uptemp==0)
1464   5                {upsmo=100;}
1465   5      
1466   5      
1467   5                       }
1468   4                       } 
1469   3      
1470   3      
1471   3       }
1472   2      
1473   2      
1474   2      
1475   2      
1476   2      
1477   2      
1478   2      
1479   2      
1480   2      
1481   2      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 25  

1482   2      
1483   2      
1484   2       
1485   2      
1486   2      
1487   2         
1488   2       
1489   2       //*****退出设定*********               
1490   2      
1491   2      
1492   2        if(kval==18)
1493   2      
1494   2       {
1495   3      
1496   3      
1497   3      
1498   3        
1499   3         write_com(0x0c);
1500   3       
1501   3      
1502   3      kval=0;
1503   3        
1504   3      dsflj=1;
1505   3      lofl=1;
1506   3      keysw=1;
1507   3        if(lofl==1)
1508   3        {
1509   4       write_com(0x80);
1510   4      
1511   4                              for(num=0;num<16;num++)
1512   4                      {
1513   5                              write_date(logo4[num]);//字幕显示
1514   5                              delay(2);
1515   5                      }
1516   4      
1517   4      
1518   4                 write_com(0x80+0x40);
1519   4      
1520   4                              for(num=0;num<16;num++)//字幕显示
1521   4                      {
1522   5                              write_date(logo3[num]);
1523   5                              delay(2);
1524   5                      }
1525   4      
1526   4      
1527   4      
1528   4      
1529   4                 lofl=0;
1530   4      
1531   4                }
1532   3      
1533   3      
1534   3      
1535   3      
1536   3      
1537   3      
1538   3        }
1539   2      
1540   2      
1541   2      
1542   2      
1543   2      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 26  

1544   2       }
1545   1      
1546   1      
1547   1      
1548   1      
1549   1      
1550   1      
1551   1      
1552   1      
1553   1      
1554   1      
1555   1       }
1556          
1557          
1558                  
1559          //步进电机函数
1560           void setmoto()
1561           {
1562   1        char num;
1563   1       //zhenfl fanfl
1564   1      
1565   1         if(zhenzhuan==1)      //正转
1566   1                 {
1567   2                       dsflj=0;
1568   2                        SETP_MOTOR_REV();
1569   2                       
1570   2                      if(second==4)//4s则停转，打开主页面显示
1571   2                      {
1572   3                      zhenzhuan=0;
1573   3                      P1=0X00;
1574   3                      dsflj=1;
1575   3                      opensw=0;
1576   3                      closesw=1;
1577   3                      keysw=1;
1578   3                 menusw=1;
1579   3      
1580   3      
1581   3                      zhenfl=1;
1582   3                      fanfl=0;
1583   3                      brigfl=0;
1584   3                       humfl=0;
1585   3      
1586   3      
1587   3                      write_com(0x80);
1588   3                              for(num=0;num<16;num++)
1589   3                      {                                                  //字幕显示
1590   4                              write_date(logo4[num]);
1591   4                              delay(2);
1592   4                      }
1593   3      
1594   3      
1595   3                              write_com(0x80+0x40);   //字幕显示
1596   3                              for(num=0;num<16;num++)
1597   3                      {
1598   4                              write_date(logo3[num]);
1599   4                              delay(2);
1600   4                      }
1601   3      
1602   3      
1603   3      
1604   3                      }
1605   2      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 27  

1606   2      
1607   2              
1608   2      
1609   2                 }
1610   1              
1611   1                      
1612   1      
1613   1                      
1614   1           if(fanzhuan==1)  //反转
1615   1                 { dsflj=0;
1616   2                      
1617   2                        SETP_MOTOR_FFW();
1618   2                       
1619   2                      if(second==4)
1620   2                      { second=0;
1621   3                              P1=0X00;
1622   3      
1623   3                      zhenfl=0;
1624   3                      fanfl=1;        
1625   3         
1626   3                       fanzhuan=0;
1627   3                       dsflj=1;
1628   3                       
1629   3                       dwbrigfl=0;
1630   3                       brigfl=0;
1631   3      
1632   3      
1633   3                      opensw=1;
1634   3                      closesw=0;
1635   3                      keysw=1;
1636   3                      menusw=1;
1637   3                  humfl=1;
1638   3                
1639   3                          
1640   3      
1641   3                      write_com(0x80);
1642   3      
1643   3                              for(num=0;num<16;num++)  //字幕显示
1644   3                      {
1645   4                              write_date(logo4[num]);
1646   4                              delay(2);
1647   4                      }
1648   3      
1649   3                                      write_com(0x80+0x40);
1650   3                              for(num=0;num<16;num++)
1651   3                      {                                                         //字幕显示
1652   4                              write_date(logo3[num]);
1653   4                              delay(2);
1654   4                      }
1655   3      
1656   3      
1657   3                       
1658   3                      }
1659   2      
1660   2      
1661   2      
1662   2                      
1663   2      
1664   2      
1665   2      
1666   2                 }
1667   1                      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 28  

1668   1       
1669   1       }
1670           
1671          void TEMPHRDSPLAY()                 //显示空气温湿度函数   写入1602
1672          {  
1673   1          num1[4]=U8T_data_H;         //温度高8位，即是整数部分  
1674   1          num1[1]=num1[4]/10; //整数十位
1675   1          num1[0]=num1[4]%10; //整数个位
1676   1              
1677   1          write_com(0x80+0x40+7);                              //显示温度
1678   1              write_date(0x30+num1[1]);
1679   1              write_date(0x30+num1[0]);
1680   1      
1681   1      
1682   1      
1683   1      
1684   1      
1685   1              num2[4]=U8RH_data_H;    //湿度高8位，即是整数部分  
1686   1          num2[3]=num2[4]/10; //整数十位
1687   1          num2[2]=num2[4]%10; //整数个位
1688   1      
1689   1          write_com(0x80+0x40+13);                     //显示湿度
1690   1              write_date(0x30+num2[3]);
1691   1              write_date(0x30+num2[2]);
1692   1      
1693   1      }       
1694          
1695          
1696            
1697           
1698          
1699          
1700           
1701          void SMOGDSPLAY()                   //显示烟雾浓度函数   写入1602
1702          {  
1703   1          num3[4]=adc0;               //温度高8位，即是整数部分 
1704   1               
1705   1      
1706   1          
1707   1               
1708   1          num3[0]=num3[4]%10;         //显示ge位  
1709   1              num3[1]=num3[4]%100/10;   //显示shi位
1710   1              num3[2]=num3[4]%1000/100;//显示百位
1711   1              
1712   1          write_com(0x80+0X40+2);                              
1713   1              write_date(0x30+num3[2]);
1714   1              write_date(0x30+num3[1]);
1715   1              write_date(0x30+num3[0]);
1716   1      
1717   1       }
1718          
1719            
1720          
1721          
1722          
1723          
1724          
1725          
1726          
1727          
1728          void BRDSPLAY() 
1729          {  
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 29  

1730   1          
1731   1               
1732   1              num5[4]=adc1;           //温度高8位，即是整数部分 
1733   1          
1734   1               
1735   1          num5[0]=num5[4]%10;         //显示ge位  
1736   1              num5[1]=num5[4]%100/10;   //显示shi位
1737   1              num5[2]=num5[4]%1000/100;//显示百位
1738   1      
1739   1          write_com(0x80+3);                  
1740   1              write_date(0x30+num5[2]);
1741   1              write_date(0x30+num5[1]);
1742   1              write_date(0x30+num5[0]);
1743   1      
1744   1        }
1745          
1746            
1747          
1748          void write_rvalue()
1749          
1750          {    
1751   1      
1752   1          
1753   1               
1754   1          num4[0]=num4[4]%10;         //显示ge位  
1755   1              num4[1]=num4[4]%100/10;   //显示shi位
1756   1              num4[2]=num4[4]%1000/100;//显示百位
1757   1      
1758   1      
1759   1      
1760   1          write_com(0x80+7);                           //显示温度
1761   1              write_date(0x30+num4[2]);
1762   1              write_date(0x30+num4[1]);
1763   1              write_date(0x30+num4[0]);
1764   1       }
1765          
1766          
1767          
1768          
1769          
1770          
1771          
1772          void init()
1773          {
1774   1      
1775   1              TH0=0X3C;                                       //定时器0置初值 0.05S
1776   1              TL0=0XBA;
1777   1      
1778   1              ET0=1;                                          //定时器0中断开启
1779   1              TR0=1;                                          //启动定时0
1780   1      
1781   1              RCAP2H =(0xFFFF-50000)/256;                //赋T2的预置值0x1000，溢出30次就是1秒钟
1782   1          RCAP2L =(0xFFFF-50000)%256;   
1783   1          TR2=1;                       //启动定时器
1784   1          ET2=1;   
1785   1      
1786   1      
1787   1          IT1=1;
1788   1              TH0=0;  //定时器0初值
1789   1              TL0=0;  //定时器0初值
1790   1          TR0=1;      //定时器0启动      
1791   1              EX1=1;  //外部中断 软件没用到
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 30  

1792   1      
1793   1      
1794   1              
1795   1      }
1796          
1797          
1798          
1799          void init2()
1800          {       
1801   1              TMOD=0X11;                                      //定时器设置
1802   1              TH0=0X3C;                                       //定时器0置初值 0.05S
1803   1              TL0=0XBA;
1804   1              EA=1;                                           //开总中断
1805   1          ES=0;//禁止串口中断         debug   2019年4月9日 15:07:13
1806   1         
1807   1              ET0=1;                                          //定时器0中断开启
1808   1              TR0=1;                                          //启动定时0
1809   1      
1810   1      
1811   1              TL1=0X3C;               //定时初值
1812   1              TH1=0XBA;               //定时初值
1813   1                               //总中断打开
1814   1              TR1=1;           //启动定时器
1815   1              ET1=1;           //软件没用到
1816   1              
1817   1      
1818   1      
1819   1              RCAP2H =(0xFFFF-50000)/256;                //赋T2的预置值0x1000，溢出30次就是1秒钟
1820   1          RCAP2L =(0xFFFF-50000)%256;   
1821   1          TR2=1;                       //启动定时器
1822   1          ET2=1;   
1823   1      
1824   1      
1825   1          IT1=1;
1826   1      
1827   1              TH0=0;  //定时器0初值  !
1828   1              TL0=0;  //定时器0初值   !
1829   1      
1830   1          TR0=1;      //定时器0启动      
1831   1              EX1=1;  //外部中断 软件没用到
1832   1                        
1833   1          ES=0;//禁止串口中断         debug   2019年4月9日 15:07:13
1834   1         
1835   1      
1836   1      }
1837                                                                                                    // 蜜蜂 池塘
1838            
1839          
1840          void open8266() //esp8266.h封装 一次命令
1841          {                
1842   1                      ManyConnect_AP(); 
1843   1      
1844   1      
1845   1                                                      write_com(0x80);
1846   1                                                      for(num=0;num<16;num++)
1847   1                                                      {
1848   2                                                              write_date(waitMess[num]);//显示提示
1849   2                                                              delay(2);          
1850   2                                                      }
1851   1                                                      delays();
1852   1                                                                              
1853   1                                        
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 31  

1854   1                                              //test open win    
1855   1                                              while(1)
1856   1                                              {
1857   2                                                              
1858   2                                                 if((Usart_Receive[0]=='+')&&(Usart_Receive[1]=='I')&&(Usart_Receive[2]=='P'))
1859   2                                                 {             
1860   3                                                            
1861   3                                                                write_com(0x80);
1862   3                                              
1863   3                                                                      for(num=0;num<16;num++)//显示提示语
1864   3                                                              {
1865   4                                                                      write_date(logo5[num]);
1866   4                                                                      delay(2);
1867   4                                                              }
1868   3                                              
1869   3                                              
1870   3                                                                write_com(0x80+0x40);
1871   3                                              
1872   3                                                                      for(num=0;num<16;num++)//显示提示语
1873   3                                                              {
1874   4                                                                      write_date(logo10[num]);
1875   4                                                                      delay(2);
1876   4                                                              }
1877   3      
1878   3                                                              closesw=1;      // 已打开标记     
1879   3                                                          delay(10);
1880   3                                                              zhenzhuan=1;// 正转 开启
1881   3                                                              fanzhuan=0;      // 返转关闭
1882   3                                                              second=0;// 秒清零 步进电机 会停
1883   3                                                              keysw=0;
1884   3                                                              menusw=0;
1885   3                                                              
1886   3                                                               break;
1887   3                                                 }
1888   2                                              }                  
1889   1                                              //end test
1890   1      
1891   1                                                      for(i = 0 ; i<20; i++)
1892   1                                                      {
1893   2                                                              Usart_Receive[i]=' ';
1894   2                                                      }
1895   1      
1896   1      }
1897          
1898          
1899          void main()//主函数
1900          {
1901   1              //kaiguan=0;//kaiguan=接采集芯片DO引脚（P3.4）可能发生冲突，尝试注释掉          debug 2019年4月8日 09:00:10
1902   1              init2(); //初始化所有时钟 
1903   1              init1602();        
1904   1      
1905   1      
1906   1      
1907   1        sudu=200;     //电机速度
1908   1        zhenzhuan=0;//上电关正转
1909   1        fanzhuan=1;//上电反转打开
1910   1        dsflj=1;
1911   1                              // 显示打开
1912   1      
1913   1        uptemp=38; //温度上限
1914   1        uphum=80;      //湿度上限
1915   1      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 32  

1916   1      
1917   1        upbrig=120;
1918   1        dwbrig=10;            //光控下限
1919   1        kwbrig=180;           // 光控上限
1920   1        upsmo=85;//烟雾浓度上限
1921   1      
1922   1        opensw=1;
1923   1        closesw=1;
1924   1        keysw=1;
1925   1        menusw=1;
1926   1        second=0;
1927   1       
1928   1                      zhenfl=0;
1929   1                      fanfl=0;
1930   1      
1931   1      
1932   1                              brigfl=1;
1933   1                              dwbrigfl=1;
1934   1                              humfl=0;
1935   1      
1936   1       adc0 = ADC0832(1,0);  //差分模式，CH0-CH1
1937   1       adc1 = ADC0832(1,1);  //差分模式，CH0-CH1
1938   1      
1939   1      
1940   1      
1941   1      
1942   1       hour=12;
1943   1       minit=5;
1944   1       secon=10; // 系统时间
1945   1      
1946   1      
1947   1      ONhour=12;      // 自动开窗时间  为了方便演示 设定 一分钟后开
1948   1      ONminit=6;
1949   1      ONsecon=10;
1950   1      
1951   1      
1952   1      OFhour=12;      // 自动关窗时间 为了方便演示 设定 一分钟后关
1953   1      OFminit=7;
1954   1      OFsecon=10;
1955   1      
1956   1      
1957   1      
1958   1              while(1)//大循环
1959   1      
1960   1              {
1961   2        
1962   2      keyscn();
1963   2      setmoto();
1964   2                                                                                                
1965   2      
1966   2      
1967   2      if (dsflj==1 )
1968   2      {
1969   3      
1970   3       //get_temp(); //SHT10调用
1971   3      //cal_wet();//SHT10调用
1972   3      
1973   3      RH(); //DHT11 调用
1974   3         
1975   3       //  U8T_data_H= SENSOR[k].temp;//SHT10调用
1976   3       //  U8RH_data_H=SENSOR[k].wet;//SHT10调用       
1977   3               
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 33  

1978   3               
1979   3      TEMPHRDSPLAY(); 
1980   3      
1981   3                                                                       
1982   3                                                                                      
1983   3       
1984   3      
1985   3       
1986   3      
1987   3      
1988   3      
1989   3      
1990   3       
1991   3      adc0 = ADC0832(1,0);  //差分模式，CH0-CH1 
1992   3      SMOGDSPLAY();
1993   3      
1994   3      adc1 = ADC0832(1,1);  //差分模式，CH0-CH1
1995   3      BRDSPLAY(); 
1996   3       
1997   3      
1998   3      
1999   3      
2000   3      
2001   3      
2002   3      
2003   3      
2004   3              if(fanfl==1)
2005   3              {
2006   4      
2007   4      
2008   4           if(adc1> kwbrig )//如果际亮度大于设定值kwbrig(默认180) 关窗
2009   4       {
2010   5                                                                        
2011   5        zhenzhuan=1;
2012   5      
2013   5      
2014   5      } 
2015   4         
2016   4         
2017   4         
2018   4         
2019   4         
2020   4               
2021   4         if(Im[2]==0x40)
2022   4               
2023   4      {
2024   5       Im[2]=0x00;
2025   5      zhenzhuan=1;
2026   5      
2027   5      }
2028   4      
2029   4      
2030   4      
2031   4      
2032   4         second=0;
2033   4      
2034   4      // if(U8T_data_H>uptemp )//如果际温度大与设定值 开窗              -------debug 2019年4月9日 15:23:32 温度检测异常
2035   4      // {
2036   4      
2037   4      // zhenzhuan=1;
2038   4       
2039   4      // }
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 34  

2040   4       
2041   4      
2042   4      
2043   4       if(adc0>upsmo )//如果烟雾实际值大于设定值 开窗
2044   4       {
2045   5      
2046   5       zhenzhuan=1;
2047   5       
2048   5       }
2049   4      
2050   4      
2051   4        
2052   4      
2053   4      
2054   4      
2055   4      
2056   4      
2057   4      
2058   4      
2059   4      
2060   4      
2061   4      
2062   4      
2063   4      
2064   4      
2065   4      }
2066   3      
2067   3              if(zhenfl==1)
2068   3              {
2069   4      
2070   4                 if(Im[2]==0x44)
2071   4               
2072   4      {
2073   5      Im[2]=0x00;
2074   5      fanzhuan=1;
2075   5      
2076   5      }
2077   4      
2078   4      
2079   4              second=0;
2080   4      // if(U8RH_data_H>uphum )//如果际湿度大与设定值 关窗             -------debug 2019年4月9日 15:23:32 湿度检测异常
2081   4      // {
2082   4      //
2083   4      // fanzhuan=1;
2084   4      //  brigfl=0;
2085   4      //  dwbrigfl=0;
2086   4      //  
2087   4      //  }
2088   4      
2089   4      
2090   4          if(adc1<dwbrig )//如果际亮度小与设定值 关窗
2091   4       {
2092   5                                                                                         
2093   5      
2094   5      fanzhuan=1;
2095   5      }
2096   4        
2097   4      
2098   4      
2099   4      
2100   4      
2101   4      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 35  

2102   4        
2103   4      
2104   4      
2105   4       
2106   4      if(IR==0)       
2107   4              {
2108   5                 delay(10);
2109   5      
2110   5                  
2111   5                      if(IR==0)
2112   5                      {
2113   6                      //while(!IR);   
2114   6                        befl=1;
2115   6                         ET2=1; 
2116   6                        fanzhuan=1;
2117   6                        con=0;
2118   6                                                                              
2119   6                       } 
2120   5      
2121   5                        
2122   5      
2123   5      
2124   5                 }
2125   4      
2126   4      
2127   4      
2128   4      
2129   4       
2130   4      
2131   4      
2132   4      
2133   4        
2134   4      
2135   4      
2136   4      }
2137   3      
2138   3      
2139   3      
2140   3      
2141   3       
2142   3      
2143   3      
2144   3       
2145   3                              if(dec==0)      
2146   3              {
2147   4                 delay(10);
2148   4      
2149   4                  
2150   4                      if(dec==0)
2151   4                      {
2152   5                      while(!dec);                                                            
2153   5                       befl=0;
2154   5                       BEEP=1; 
2155   5                        
2156   5      
2157   5                       } 
2158   4      
2159   4      
2160   4                 }
2161   3         
2162   3      
2163   3      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 36  

2164   3                              
2165   3                      
2166   3      
2167   3      
2168   3      
2169   3      
2170   3      
2171   3      
2172   3      
2173   3              DSdat=secon;
2174   3                      write_com(0x80+14);
2175   3                      write_sfm();
2176   3      
2177   3                      DSdat=minit;
2178   3                  write_com(0x80+11);
2179   3                  write_sfm();
2180   3      
2181   3                      DSdat=hour;
2182   3              write_com(0x80+0x08);
2183   3                      write_sfm();
2184   3      
2185   3      
2186   3      
2187   3      
2188   3      
2189   3      
2190   3      
2191   3      
2192   3      
2193   3      
2194   3      
2195   3      
2196   3      
2197   3      
2198   3      }
2199   2      
2200   2      
2201   2      }
2202   1      
2203   1      
2204   1      }
2205           
2206          
2207          
2208          
2209          
2210          
2211          
2212          
2213           
2214          //定时器2中断
2215          timer2() interrupt 5 
2216          {
2217   1          TF2=0; //!!!注意!!! 定时器2必须由软件对溢出标志位清零，硬件不能清零，这里与定时器0和定时器1不同!!!
2218   1       
2219   1      
2220   1              count0++;
2221   1              con++;
2222   1      
2223   1              if(count0==15)
2224   1              {
2225   2                      count0=0;
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 37  

2226   2              second++;
2227   2              }       
2228   1                      
2229   1                              
2230   1                      
2231   1           if(befl==1)
2232   1         {
2233   2                      if(con==20)
2234   2              {
2235   3                      con=0;
2236   3              //BEEP=~BEEP;  消音
2237   3                      
2238   3                      
2239   3                              
2240   3              }       
2241   2          
2242   2              }
2243   1       
2244   1              
2245   1      
2246   1      
2247   1      
2248   1      }
2249             
2250          
2251          
2252          
2253            void time0(void) interrupt 1 using 1          //定时中断子程序
2254          {
2255   1              TH0=0X3C;                                                       //重赋初值
2256   1              TL0=0XBA;
2257   1      
2258   1        
2259   1      
2260   1      
2261   1      
2262   1      
2263   1      }
2264          
2265                                                                                      
2266          
2267          
2268          
2269            //*********************************中断服务函数**************************************
2270          void  time0_int(void) interrupt 3 
2271          {
2272   1      
2273   1        
2274   1              TH0=0X3C;                                                       //重赋初值
2275   1              TL0=0XBA;               //定时初值
2276   1              TR1=1;
2277   1              time++;
2278   1       
2279   1                 
2280   1              if(time==20)
2281   1              {
2282   2                      time=0;
2283   2              secon++;        
2284   2                      
2285   2                  
2286   2                 
2287   2      
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 38  

2288   2      
2289   2              }
2290   1              
2291   1                      
2292   1              if(secon==60)
2293   1              {
2294   2                      secon=0;
2295   2              minit++;
2296   2              
2297   2                              
2298   2                              
2299   2              }       
2300   1          
2301   1              
2302   1              if(minit==60)
2303   1              {
2304   2                      minit=0;
2305   2              hour++; 
2306   2                              if(hour==24)
2307   2              {
2308   3                      hour=0;
2309   3          }   
2310   2      
2311   2                
2312   2                      
2313   2      
2314   2                  
2315   2              }       
2316   1      
2317   1      
2318   1              
2319   1      
2320   1      
2321   1      
2322   1      
2323   1      
2324   1      
2325   1       
2326   1              if(fanfl==1)
2327   1              {
2328   2      
2329   2       
2330   2      
2331   2      
2332   2      
2333   2        if((ONhour==hour)&&(ONminit==minit)&&(ONsecon==secon))//定时开窗
2334   2        {
2335   3                              
2336   3      
2337   3      
2338   3       zhenzhuan=1;
2339   3      
2340   3       }
2341   2                       
2342   2      }
2343   1      
2344   1      
2345   1      
2346   1      
2347   1      
2348   1      
2349   1              if(zhenfl==1)
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 39  

2350   1              {
2351   2      
2352   2      
2353   2      
2354   2        if((hour==OFhour)&&(minit==OFminit)&&(secon==OFsecon)) //定时关窗
2355   2        {
2356   3                              
2357   3      
2358   3      
2359   3       fanzhuan=1;
2360   3      
2361   3      
2362   3      
2363   3      
2364   3      }
2365   2        
2366   2      
2367   2      }
2368   1      
2369   1      
2370   1      
2371   1      
2372   1      
2373   1      
2374   1      
2375   1      
2376   1      
2377   1      
2378   1      
2379   1      
2380   1       
2381   1      
2382   1      
2383   1      
2384   1      
2385   1      
2386   1      
2387   1      }
2388          
2389          
2390          
2391          
2392          //*********************************中断服务函数**************************************
2393          // 遥控 解码 函数 接收头 接外部 中断口 P3.3
2394          /************************************************************************/      
2395          //外部中断解码程序
2396          void intersvr1(void) interrupt 2 using 1
2397          {
2398   1          Tc=TH0*256+TL0; //定时器清空只记TC 值                                              //提取中断时间间隔
             -背
2399   1          TH0=0; 
2400   1          TL0=0;              //定时中断重新置零
2401   1      
2402   1              if((Tc>Imin)&&(Tc<Imax))//启动码判定 两个时间对比0.9MS  
2403   1              {  
2404   2              m=0;
2405   2              f=1;
2406   2              return;
2407   2              }       //找到启始码
2408   1              
2409   1              if(f==1)
2410   1              {
C51 COMPILER V9.00   WINDOW                                                                05/04/2019 11:13:32 PAGE 40  

2411   2              if(Tc>Inum1&&Tc<Inum3) //判定是0该还是1 是0 1.125MS 是1  2.25MS
2412   2                      {
2413   3                              Im[m/8]=Im[m/8]>>1|0x80; m++;  //存0
2414   3                      }
2415   2                      if(Tc>Inum2&&Tc<Inum1) 
2416   2              {
2417   3                              Im[m/8]=Im[m/8]>>1; m++; //     存1
2418   3                      }
2419   2                      if(m==32)       //32位存储完毕
2420   2                      {
2421   3                              m=0;  
2422   3                              f=0;
2423   3                              if(Im[2]==~Im[3])  //反码检查
2424   3                              {        
2425   4                                      IrOK=1;         //OK 完成
2426   4                              }
2427   3                              else IrOK=0;   //取码完成后判断读码是否正确
2428   3                      }
2429   2                      //准备读下一码
2430   2              }
2431   1              
2432   1      }
2433          /************************************************************************/
2434          //************zheng 0X45; stop  0X46; fan  0X47   aut  0X43;


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5487    ----
   CONSTANT SIZE    =    418    ----
   XDATA SIZE       =     79       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     63    ----
   IDATA SIZE       =     16    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
